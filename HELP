PC-BASIC 3.23 REFERENCE

This file is copyright (c) 2014 Rob Hagemans and licensed under a 
Creative Commons Attribution-ShareAlike 4.0 International License.


INTERACTIVE MODE
----------------
The screen is divided into 'logical lines' whose length can exceed the width
of the physical line. The logical line includes all the text on the line. If 
the line has been wrapped or broken by <CTRL+J>, the logical line extends 
into the next physical line. 
The following keys have a special effect:
<UP> or <CTRL+6>            Move the cursor up, except at line 1.
<DOWN> or <CTRL+->          Move the cursor down, except at line 24. Line 25
                            cannot be reached with the arrow keys. 
<LEFT> or <CTRL+]>          Move the cursor left. The left edge of the screen 
                            wraps around, except at line 1.
<RIGHT> or <CTRL+/>         Move the cursor right. The right edge of the 
                            screen wraps around, except at line 24.
<CTRL+LEFT> or <CTRL+B>     Move to the first letter of the previous word. A 
                            word consists of letters A-Z and figures 0-9.
<CTRL+RIGHT> or <CTRL+F>    Move to the first letter of the next word.
<TAB> or <CTRL+I>           Move the cursor to the next tab stop. Tab stops
                            are 8 columns wide.
<BACKSPACE> or <CTRL+H>     Delete the character left of the cursor, shift 
                            all further characters on the logical line one 
                            position to the left and change the attributes of 
                            those characters to the current attribute. At the 
                            left edge of the screen, this does the same as 
                            <DEL>.
<DEL> or <CTRL+BACKSPACE>   Delete the character at the cursor and shift all 
                            further characters one position to the left, 
                            changing attributes to current.
<ESC> or <CTRL+[>           Delete the current logical line
<CTRL+END> or <CTRL+E>      Delete all characters from the cursor to the end 
                            of the logical line.
<CTRL+BREAK> or <CTRL+C>    Jump to the first column of the next line, 
or <CTRL+SCROLL_LOCK>       without executing or storing the line under the 
                            cursor.
<ENTER> or <CTRL+M>         Execute or store the current screen line. The 
                            complete line on the screen is considered part of 
                            the command, including any text you did not type. 
                            A line starting with a number is stored as a 
                            program line.
<END> or <CTRL+N>           Move the cursor to the first position after the 
                            end of the logical line.
<HOME> or <CTRL+K>          Move the cursor to the top left of the screen.
<CTRL+HOME> or <CTRL+L>     clear the screen and move the cursor to the top 
                            left of the screen.
<CTRL+ENTER> or <CTRL+J>    Move to the first column of the next line, 
                            connecting the two lines into one logical line.
<CTRL+G>                    Beep.
<PAUSE> or <CTRL+NUM_LOCK>  Pause. Press another key to resume.
<CTRL+PRT_SC>               Echo screen output to the printer.
<SHIFT+PRT_SC>              Print the screen.
<INS> or <CTRL+R>           Toggle INSERT mode. In INSERT mode, characters  
                            are inserted rather than overwritten at the 
                            current location. If insertion causes the line to 
                            extend the physical screen width, the logical 
                            line extends onto the next line. Arrow keys exit 
                            INSERT mode.


PROGRAMS
--------
A program line is entered by starting a line with a line number. All program 
lines must have a line number. Line numbers range from 0 to 65535 inclusive.
It is not possible to enter a line number higher than 65529, but these can 
exist in loaded programs. Lines between 65530 and 65535 are not visible in 
the program's LIST.
Within one program line, statements are separated by colons (:). The maximum
length of a program line is 255 characters.
Programs can be saved to disk with SAVE and loaded with LOAD. A program can 
be started using RUN or GOTO.


RUNMODE
-------
When a program is started, the commands in the program are followed until the
program quits and returns to interactive mode or until user input is required.
In program mode, a few keys have immediate effect:
<PAUSE> or <CTRL+NUM_LOCK>  Pause execution. Press another key to resume.
<CTRL+BREAK>                Stop execution and return to interactive mode.
or <CTRL+SCROLL_LOCK>       A BREAK message is printed.


INPUT MODE
----------
If user input is required by the statements INPUT, LINE INPUT, or RANDOMIZE, 
BASIC goes into input mode. In input mode, keys have the same effect as in
interactive mode. However, the following keys have different effect:
<CTRL+BREAK> or <CTRL+C>    Stop execution and return to interactive mode.
or <CTRL+SCROLL_LOCK>       A BREAK message is printed.
<ENTER>                     Finish input and return to the previous mode.


ERROR CODES
-----------
1   NEXT without FOR
2   Syntax error
3   RETURN without GOSUB
4   Out of DATA
5   Illegal function call
6   Overflow
7   Out of memory
8   Undefined line number
9   Subscript out of range
10  Duplicate Definition
11  Division by zero
12  Illegal direct
13  Type mismatch
14  Out of string space
15  String too long
16  String formula too complex
17  Can't continue
18  Undefined user function
19  No RESUME
20  RESUME without error
21
22  Missing operand
23  Line buffer overflow
24  Device Timeout
25  Device Fault
26  FOR without NEXT
27  Out of paper
28
29  WHILE without WEND
30  WEND without WHILE
31--49
50  FIELD overflow
51  Internal error
52  Bad file number
53  File not found
54  Bad file mode
55  File already open
56
57  Device I/O error
58  File already exists
59--60
61  Disk full
62  Input past end
63  Bad record number
64  Bad file name
65
66  Direct statement in file
67  Too many files
68  Device Unavailable
69  Communication buffer overflow
70  Permission Denied
71  Disk not Ready
72  Disk media error
73  Advanced Feature
74  Rename across disks
75  Path/File access error
76  Path not found
77  Deadlock
Any error code that does not have a message associated to it will generate
the message "Unprintable error".


LITERALS
--------
String literals can be specified between double quotes. There is no escaping
mechanism. To include a double quote or a special character in a string, use
the CHR$() function.
Numeric literals:
  [{+|-}] [digits] [.] [digits] [ { {E|D} [{+|-}] [digits] | # | ! | % } ]
  &{H|h}hexadecimal_digits
  &[O|o]octal_digits
Trailing % is ignored, ! or # specify the type.
Examples of valid numeric literals:
  -1
  42
  42!
  42#
  1.3523523
  .235435
  -.3
  3.
  .         (this equals 0!)
  .e        (0!)
  .D        (0#)
  1.1e+7
  1.1d+7
  1e2
  1e-2
  &7
  &hffff
  &O20
Hexadecimal literals can be specified like &HFFFF. They must range between 
-&H7FFF and &HFFFF. &HFFFF = -&H1 = &H-1 .
Octal literals can be specified as &o777 or &777.


VARIABLES
---------
Variable names must start with a letter; all characters of the variable name
(except the type character) must be letters (A-Z), figures (0-9), or a dot (.)
Only the first 40 characters in the name are significant. Variable names must
not be identical to keywords -- roughly, statement or function names; more 
accurately, anything that has a defined keyword token, including such words as
TO but not, for instace, AS. There is no particular logic to this. For each 
name, four different variables may exist corresponding to the four types. 
That is, you can have A$, A%, A! and A# with different values. Which one of 
those is called A depends on the settings in DEFINT/DEFDBL/DEFSNG/DEFSTR. 
The default is A==A!. In addition, you can have arrays A$(), A%(), A!(), A#() 
which are separate from the scalar variables of the same name.


TYPES
-----
PC-BASIC recognises four variable types, distinguished by their type character
which is the last character of the variable's name:
char    type                    size
 $      string                  3 bytes plus allocated string space
 %      integer                 2 bytes 
 !      single-precision float  4 bytes
 #      double-precision float  8 bytes 
If the type character is not specified, the first letter of the name determines
the type through DEFINT/DEFSTR/DEFSNG/DEFDBL. Unless otherwise specified, all
variables are single-precision floats.
Internal representation:
-   Line numbers are two-byte unsigned little-endian.
-   Integers are two-byte signed little-endian two's complement ints.
-   Booleans are represented as 0 (FALSE); -1 or other non-zero (TRUE). 
-   Floats are represented in the Microsoft Binary Format (MBF).
Machine limits:
    Line numbers are in [0, 65529]. 65530-65535 are unused.
    Integers are in [-32768, 32767]. 
    Floats: largest 1.701412E+38; smallest 2.938726E-39
    Double-precision floats can hold more decimals but not larger or smaller 
    numbers.
    
    
ARRAYS
------
Arrays of any type can be generated. Arrays are indexed with round or square 
brackets; even mixing brackets is allowed. The following work: A[0] A(0) 
A(0] A[0). Multidimensional arrays are specified with commas: A(0,0) etc.
By default, arrays are counted from 0. This can be changed to 1 using 
 OPTION BASE 1. Arrays can be allocated using DIM. If all indices of the array
are 10 or less, arrays can be used without using the DIM command. The first 
referencing of the array (read or write) will automatically dimension it with 
a maximum index of 10 and the same number of indices as in the first 
referencing. To re-allocate an array, first the old array must be deleted 
through CLEAR or ERASE.


OPERATORS
---------
Order of precedence:    
    ^	Exponentiation
    -	Negation
    *	Multiplication  
    /	Floating-point Division   \   Integer division   MOD  Integer modulo
    +	Addition   - Subtraction
NOTE: Exponentiation is tighter bound than negation: -1^2 = -1 but (-1)^2 = 1.
Relational:
    =       Equal
    <> ><   Not equal
    <       Less than
    >       Greater than
    <= =<   Less than or equal
    >= =>   Greater than or equal
Boolean:
    NOT, AND, OR, XOR, EQV, IMP


ATTRIBUTES, PALETTES AND COLOURS
--------------------------------


INTERNAL REPRESENTATION OF NUMBERS AND THE MICROSOFT BINARY FORMAT
------------------------------------------------------------------


KEYWORD LIST
------------


ABS(x) function
---------------
Returns the absolute value of 'x'. 'x' is an expression with a numeric value.
If 'x' has a string value, ABS raises TYPE MISMATCH.


ASC(x) function
---------------
Returns the ASCII code for the first character of x. x is an expression with 
a string value.
ERRORS:
-   If 'x' has a numeric value, ASC raises TYPE MISMATCH.
-   If 'x' equals "", ASC raises ILLEGAL FUNCTION CALL.


ATN(x) function
---------------
Returns the inverse tangent of x. 'x' is a numeric-valued expression that gives 
the angle in radians. Unless BASIC is run with the --double option, ATN(x) 
returns a single-precision value.
NOTES:
-   ATN(1) differs in the least significant digit from GW-BASIC.
ERRORS:
-   If 'x' has a string value, ATN raises TYPE MISMATCH.


AUTO statement
AUTO [ { line_number | . } ] [, [increment]] 
--------------
Enter automatic line numbering mode (AUTO mode). In AUTO mode, line numbers 
are automatically generated when <ENTER> is pressed.
Line numbering starts at 'line_number', if specified. If . is specified, line 
numbering starts at the last program line that was stored. Otherwise, line
numbering starts at 10. 
Each next line number is incremented by 'increment', if specified. If a comma 
is used withoud specifying an increment, the last increment specified in an 
AUTO command is used. If not, increment defaults to 10.
If a program line exists at a generated line number, a '*' is shown after the 
line number. To avoid overwriting this line, leave it empty and press <ENTER>.
To exit AUTO mode, press <CTRL+BREAK> or <CTRL+C>. The line being edited at 
that point is not saved. BASIC will return to command mode, even if AUTO was 
run from a program line.
ERRORS:
-  If line_number is not an unsigned-integer value between 0 and 65529, 
   inclusive, SYNTAX ERROR is raised.
-  In AUTO mode, pressing <ENTER> on an empty line with number larger than 
   65519, UNDEFINED LINE NUMBER is raised.


BEEP statement
BEEP
--------------
Beeps at 800Hz for 0.25s.


BLOAD statement
BLOAD filename [, offset]
---------------
Raises ADVANCED FEATURE.
NOTES:
-  In GW-BASIC, BLOAD loads an image file into memory. 
   This is not implemented in PC-BASIC 3.23.   


BSAVE statement
BSAVE filename, offset, length
---------------
Raises ADVANCED FEATURE.
NOTES:
-  In GW-BASIC, BSAVE saves a region of memory to an image file. 
   This is not implemented in PC-BASIC 3.23.  


CALL statement
CALL address, variables
--------------
Raises ADVANCED FEATURE.
NOTES:
-  In GW-BASIC, CALL executes a machine language subroutine.
   This is not implemented in PC-BASIC 3.23.  


CDBL(x) function
----------------
Converts the numeric-valued expression 'x' to a double-precision value.
ERRORS:
-  If 'x' has a string value, TYPE MISMATCH is raised.


CHAIN statement
CHAIN [MERGE] program [, [line_number] [, [ALL] [, DELETE range]]]
---------------
Loads 'program' into memory and runs it, optionally transferring variables.
If 'line_number' is specified, it must be a numeric-valued expression. It 
will be interpreted as a line number is the new program. If 'line_number' is
negative, it will be interpreted as its two's-complement. 
If ALL is specified, all variables are transferred. If not, the variables 
specified in a COMMON statement are transferred. 
IF MERGE is specified, 'program' is merged into the existing program. To be 
able to use this, 'program' must be saved as ASCII.
If DELETE is specified, the 'range' of line numbers is deleted from the 
existing code before the merge. This is pointless without MERGE.


CHDIR statement
CHDIR pathname
---------------
Change the working directory to 'pathname'. 'pathname' is a string-valued 
expression which can be absolute or relative to the current path. 'pathname'
must be specified with MS-DOS path separators (\). CHDIR first looks for the
exact, case-sensitive (on Unix) path 'pathname'; if this does not exist then
an uppercase version truncated to 8.3 is attempted.
ERRORS:
-  If no matching path is found, PATH NOT FOUND is raised.
-  If 'pathname' is not string-valued, TYPE MISMATCH is raised.
-  If 'pathname' is empty, BAD FILE NAME is raised.


CHR$(x) function
----------------
Returns the character with ASCII code 'x'. 'x' must have a numeric value 
between 0 and 255 (inclusive). 
ERRORS:
-  If 'x' is a string value, TYPE MISMATCH is raised.
-  If 'x' is not -32768<=x<=32767, OVERFLOW is raised.
-  If 'x' is not 0<=x<=255, ILLEGAL FUNCTION CALL is raised.


CINT(x) function
----------------
Converts the numeric-valued expression 'x' to a signed integer.
ERRORS:
-  If 'x' is a string value, TYPE MISMATCH is raised.
-  If 'x' is not -32768<=x<=32767, OVERFLOW is raised.


CIRCLE statement
CIRCLE (x, y), radius [, [colour] [, [start] [, [end] [, aspect] ] ]
----------------
Draw an ellipse or ellipse sector. The midpoint of the ellipse is at 'x','y'.
'radius' is the radius, in pixels, along the long axis.
'colour' is the colour attribute.
If 'start' and 'end' are specified, a sector of the ellipse is drawn from 
'start' radians to 'end' radians, with zero radians the intersection with the 
right-hand x axis. If a negative value is specified, the arc sector is 
connected by a line to the midpoint.
'aspect' specifies, the ratio between the y radius and the x radius. If it is
not specified, the standard value for the SCREEN mode is used (see there), so
as to make the ellipse appear like a circle on the original hardware. 
NOTES: 
-  The rectangular pixels of some screen modes are currently not faithfully 
   reproduced by PC-BASIC 3.23, making default circles look like ellipses.
-  For 'aspect'<>1, the midpoint algorithm used does not pixel-perfectly 
   reproduce GW-BASIC's ellipses.
ERRORS:
-  In text mode (SCREEN 0), CIRCLE raises ILLEGAL FUNCTION CALL.
-  If 'start' or 'end' is not between 0 and 2pi, ILLEGAL FUNCTION CALL raised.
-  If the statement ends with a comma, MISSING OPERAND is raised.


CLEAR statement
CLEAR [expr] [, [mem_limit] [, stack_size] ]
---------------
Sets all variables to null. Closes all files. Clears all DEF FN functions. 
Clears all COMMON declarations. Turns off all sound. Resets music foreground.
Turns PEN and STRIG off. Clears all ON ERROR traps. Resets ERR and ERL to zero.
Resets the random number generator.
NOTES:
-  In GW-BASIC, 'mem_limit' specifies the upper limit of usable memory, and 
   'stack_size' specifies the amount of memory available to the stack and to
   string space. These are not implemented.
-  In GW-BASIC, If 'mem_limit' or 'expr' are too low, OUT OF MEMORY is raised.
-  The purpose of 'expr' is unknown.
ERRORS:
-  If 'mem_limit' or 'stack_size' equal 0, ILLEGAL FUNCTION CALL is raised.
-  If 'expr' is negative, ILLEGAL FUNCTION CALL is raised.
-  If 'expr','mem_limit','stack_size' are not in [-32768, 32767], OVERFLOW.


CLOSE statement
CLOSE [[#] file_1 [, [#] file_2 [, ...] ]
---------------
Closes files. 'file_1', 'file_2' etc are numeric-valued expressions yielding 
file numbers. If no file numbers are specified, all open files are closed.
The hash (#) is optional and has no effect.
NOTES:
-  If 'file_1' etc. is not an open file, no error is raised.
ERRORS:
-  If 'file_1' etc. is not in [-32768,32767], raises OVERFLOW.
-  If 'file_1' etc. is not in [0,255], raises ILLEGAL FUNCTION CALL.
-  If 'file_1' etc. is string-valued, TYPE MISMATCH is raised.
-  If the statement ends in a comma, MISSING OPERAND is raised.
-  If an error occurs, the files before the erratic value are closed.


CLS statement
CLS [x][,]
------------
Clears the screen or part of it. 
'x' is a numeric valued expression:
-  If 'x' equals 0, the whole screen is cleared.
-  If 'x' equals 1, the graphics view region is cleared.
-  If 'x' equals 2, the text view region is cleared.
If 'x' is not specified, in SCREEN 0 the text view region is cleared;
in other screens, the graphics view region is cleared.
The comma is optional and has no effect.
ERRORS:
-  If 'x' is string valued, TYPE MISMATCH is raised.
-  If 'x' is not 0,1, or 2, ILLEGAL FUNCTION CALL is raised.
-  If 'x' is not in [-32768, 32767], OVERFLOW is raised.
-  If no comma is specified but more text follows, ILLEGAL FUNCTION CALL.
-  If a comma is specified followed by more, SYNTAX ERROR.
-  If an error occurs, the screen is not cleared.


COLOR statement
COLOR [foreground] [, [background] [, border] ]    (in SCREEN 0)
COLOR [palette_0] [, palette]                      (in SCREEN 1)
COLOR [foreground] [, palette_0]                   (in SCREEN 7,8,9)
---------------
Changes the current colour attributes and/or palette colours. The syntax and
working of this command are different in different SCREEN modes.
In SCREEN 0 (text mode):
    'foreground' is a numeric expression with a value between 0 and 31 (incl.)
    This specifies the new foreground attribute. Attributes 16--31 incl. are 
    blinking versions of attributes 0--15 incl.
    'background' is a numeric expression with a value between 0 and 15 (incl.)
    This specifies the new background attribute. It is taken MOD 16: Values 
    8--15 incl. produce the same colour as 0--7 incl.
    'border' is a numeric expression between 0 and 15 (incl.). This is 
    optional and has no effect.
    All new characters printed will take the newly set attributes. Existing
    characters on the screen are not affected.
In SCREEN 1 (CGA graphics):
    'palette_0' is a numeric expression with a value between 0 and 255 (incl.)
    This sets the palette colour associated with attribute 0; by default, the
    background has this attribute. All pixels with this attribute will 
    change colour. The palette colour value is taken from the VGA 64-colour
    set. 'palette_0' is taken MOD 64.  
    'palette' is a numeric expression with a value between 0 and 255 (incl.)
    If 'palette' is odd, the standard CGA palette (cyan, magenta, grey) is set.
    If 'palette' is even, the alternative palette (green, red, brown) is set.
    All pixels with attributes 1,2,3 will change colour to the new palette.
In SCREENs 7,8,9:
    'foreground' is a numeric expression with a value between 1 and 15 (incl.)
    This sets the new foreground attribute. This applies only to new characters
    printed or pixels plotted.
    'palette_0' is a numeric expression with a value between 0 and 15 (incl.)
    This sets the palette colour associated with attribute 0; by default, the
    background has this attribute. All pixels with this attribute will 
    change colour. 
    In SCREEN 7 and 8, the 'palette_0' colour is taken from the first 8 of 
    the 16-colour EGA set. 'palette_0' is taken MOD 8.
    IN SCREEN 9, the palette colour value is taken from the 64-colour VGA set.
NOTES:
-   In GW-BASIC, the 'border' value in SCREEN 0 sets the attribute of the 
    screen border. This is not implemented in PC-BASIC 3.23.     
ERRORS:
-   If any of the parameters has a string value, TYPE MISMATCH is raised.
-   If any of the parameters is not in [-32768,32667], OVERFLOW is raised.
-   In SCREEN 0, if 'foreground' is not in [0,31], 'background' is not in 
    [0,15] or 'border' is not in [0,15], ILLEGAL FUNCTION CALL is raised.
-   In SCREEN 1, if any of the parameters is not in [0,255], ILLEGAL FUNCTION
    CALL is raised.
-   In SCREEN 2, ILLEGAL FUNCTION CALL is raised.         
-   In SCREENs 7,8,9, if 'foreground' is not in [1,15] or 'background' is not
    in [0,15], ILLEGAL FUNCTION CALL is raised.
    
 
COM(port) statement
COM(port) { ON | OFF | STOP }
----------------
When using ON, enables ON COM(x) event trapping of the emulated serial port. 
When using OFF, disables trapping.
When using STOP, halts trapping until COM(x) ON is used. Events that occur 
while trapping is halted will trigger immediately when trapping is re-enabled.
'port' is a numeric expression with a value of 1 or 2. This specified which
serial port (COM1: or COM2:) is trapped.


COMMON statement
COMMON [ [var_0] [, [var_1] [, [...] ] ] ]
----------------
Specifies variables to be passed as common variables to the program called 
with CHAIN. 'var_0', 'var_1', ... are names of variables or arrays. Array names
must be followed by round or square brackets. Brackets may also be mixed (] [).
The statement may end with one or more commas. 


CONT statement
CONT [ anything ]
--------------
Resumes execution of a program that has been halted by STOP, END, <CTRL+C>, or 
 <CTRL+BREAK>.
ERRORS:
-   If no program is loaded, a program has not been run, after a program line 
    has been modified and after CLEAR, CONT raises CAN'T CONTINUE.
-   If the break occurred in a direct line, CONT raises CAN'T CONTINUE    


COS(x) function
---------------
Returns the cosine of 'x'. 'x' is a numeric-valued expression that gives the 
angle in radians. 
Unless BASIC is run with the --double option, COS(x) returns a 
single-precision value.
NOTES:
-   COS(x) usually differs from the value returned by GW-BASIC. For one-digit 
    values, the difference is only in the least significant figure, but it
    increases with the size of the angle.
ERRORS:
-   If 'x' has a string value, COS raises TYPE MISMATCH.
     

CSNG(x) function
----------------
Converts the numeric-valued expression 'x' to a single-precision value.
ERRORS:
-   If 'x' has a string value, CSNG raises TYPE MISMATCH.


CSRLIN function
---------------
Returns the screen row of the cursor on the active page. 
CSRLIN is between 1 and 25, inclusive. Note that CSRLIN has no brackets.


CVI(x) function
---------------
Converts a two-byte string to a signed integer.
'x' should be a string-valued expression that represents an integer using
little-endian two's complement encoding. Only the first two bytes are used.
ERRORS:
-   If 'x' has a number value, TYPE MISMATCH is raised.


CVS(x) function
---------------
Converts a four-byte string to a single-precision floating-point number.
'x' should be a string-valued expression that represents a single-precision
number in Microsoft Binary Format.. Only the first four bytes are used.
ERRORS:
-   If 'x' has a number value, TYPE MISMATCH is raised.


CVD(x) function
---------------
Converts an eight-byte string (internal representation) to a single.
'x' should be a string-valued expression. Only the first eight bytes are used.
ERRORS:
-   If 'x' has a number value, TYPE MISMATCH is raised.
 

DATA statement
DATA [ [const_0] [, [const_1] [, ... ]
--------------
Specifies the data that can be read by the READ statement. 'const_0', ...
are string and number literals or may be empty. String literals can be given
with or without quotation marks. If quotation marks are omitted, leading and
trailing whitespace is ignored and commas or colons will terminate the data
statement.
ERRORS:
-   If the type of the literal does not match that of the corresponding READ 
    statement, a SYNTAX ERROR occurs on the DATA statement.
    

DATE$ function
--------------
Returns the system date as a string in the format "mm-dd-yyyy".
Note that DATE$ has no brackets.


DATE$ statement
DATE$ = date
---------------
Sets the system date. 'date' is a string-valued expression that represents a 
date in one of the formats: "mm-dd-yyyy", "mm/dd/yyyy", "mm-dd-yy", "mm/dd/yy".
Of these, mm must be in [01, 12], dd must be in [01, 31]. If specified as yyyy,
the year must be in [1980, 2099]. If specified as yy, the year must be in the
range [00, 77], in which case it is interpreted as 2000--2077, or in the range
 [80, 99], which is interpreted as 1980-1999.
NOTES:
-   The system date is not actually changed; rather, PC-BASIC remembers the 
    offset from the true system date. This avoids requiring user permission
    to change the system time
-   GW-BASIC appears to accept invalid dates such as "02-31-2000". PC-BASIC
    raises ILLEGAL FUNCTION CALL for these.
ERRORS:
-   If the value of 'date' is not in the format specified above, DATE$ raises
    ILLEGAL FUNCTION CALL.
-   If 'date' yields a numeric value, TYPE MISMATCH is raised.


DEF FN statement
DEF FN name[( arg_0 [, arg_1 [, ...] )] = expression
----------------
Defines a function. 'name' must be a legal variable name. The function will 
then be called FNname (or FN name). Spaces between FN and name are optional.
'arg0', ... must be legal variable names; these are the parameters of the
function. 'expression' must be a legal PC-BASIC expression that may use the
parameters 'arg_0', 'arg_1', ... . On calling FNname(...), 'expression' is 
evaluated with the supplied parameters substituted. The result of the 
evaluation is then the value of FNname.


DEFINT statement
DEFINT letters
----------------
Sets the default type for variables starting with 'letters' to integer (%). 
This is the type that is assumed if no type character is specified. 'letters' 
are letters of the alphabet separated by commas or ranges specified with a 
dash: for example, DEFINT A,B,C-Z


DEFDBL statement
DEFDBL letters
----------------
Sets the default type for variables starting with 'letters' to double (#). 
This is the type that is assumed if no type character is specified. 'letters' 
are letters of the alphabet separated by commas or ranges specified with a 
dash: for example, DEFDBL A,B,C-Z


DEFSNG statement
DEFSNG letters
----------------
Sets the default type for variables starting with 'letters' to single (!). 
This is the type that is assumed if no type character is specified. 'letters' 
are letters of the alphabet separated by commas or ranges specified with a 
dash: for example, DEFSNG A,B,C-Z. DEFSNG A-Z is the default setting.


DEFSTR statement
DEFSTR letters
----------------
Sets the default type for variables starting with 'letters' to string ($). 
This is the type that is assumed if no type character is specified. 'letters' 
are letters of the alphabet separated by commas or ranges specified with a 
dash: for example, DEFSTR A,B,C-Z.


DEF SEG statement
DEF SEG [=address]
-----------------
Does nothing. 'address' is a numeric-valued expression in [-32768, 65535].
NOTES:
-   In GW-BASIC, sets the segment address to be used by BLOAD, BSAVE, CALL, 
    PEEK, POKE, or USR. This is not implemented in PC-BASIC.
-   If 'address' is negative, it is interpreted as its two's complement.
-   If 'address' is not specified, the segment is set to the GW-BASIC data
    segment.
ERRORS:
-   If 'address' is not in [-32768, 65535], OVERFLOW is raised.
-   If 'address' has a string value, TYPE MISMATCH is raised.


DEF USR statement
DEF USR[n] = address
-----------------
Does nothing. 'n' is a digit between 0 and 9 inclusive. 'address' is a numeric-
valued expression in [-32768, 65535].
NOTES:
-   In GW-BASIC, sets the starting address of an assembly-language function. 
    This is not implemented in PC-BASIC.
-   If 'address' is negative, it is interpreted as its two's complement.
ERRORS:
-   If 'address' is not in [-32768, 65535], OVERFLOW is raised.
-   If 'address' has a string value, TYPE MISMATCH is raised.

 
DELETE statement
DELETE [ [line_number_0] - [line_number_1] ]
DELETE [line_number_0]
----------------
Deletes lines from the program, starting with 'line_number_0' up to 
'line_number_1', which must be line numbers in the range [0, 65529] or a .
to indicate the last line edited.
Also stops program execution and returns to interactive mode.
ERRORS:
-   If a line number is greater than 65529, SYNTAX ERROR is raised.
-   If the range specified does not include any program lines stored, DELETE
    raises ILLEGAL FUNCTION CALL.
    
    
DIM statement
DIM name  { ( | [ } limit_0 [, limit_1 [, ...] ] { ) | } ]   
-------------
Dimensions (allocates memory for) arrays. 'name' is a legal variable name
specifying the array to be dimensioned. 'limit_0', ... are number-valued 
expressions that specify the greatest index allowed at that position. Mixed
brackets are allowed. The least index allowed is determined by OPTION BASE.
The DIM statement also fixes the number of indices of the array. 
An array can only de dimensioned once; to re-dimension an array, ERASE or 
 CLEAR must be executed first. 
If an array is used without a DIM statement, its maximum indices are set at 10
for each index position used. If an array's DIM statement specifies no indices,
 it is dimensioned with a single index with maximum 10.
NOTES:
-   The size of arrays is limited by the available memory. In GW-BASIC, an 
    OUT OF MEMORY is raised if the array exceeds the size of available variable
    space. This is not currently implemented in PC-BASIC.
-   The maximum number of indices is, theoretically, 255. However, in practice,
    it is limited by the 255-byte limit on the length of program lines.
ERRORS:
-   If 'name' has already been dimensioned, DUPLICATE DEFINITION is raised.
-   If an index is empty, SYNTAX ERROR is raised.
-   If an index is missing at the end, MISSING OPERAND is raised.
-   If 'limit_0', ... are not within [-32768, 32767], OVERFLOW is raised.        
-   If 'limit_0', ... are negative, ILLEGAL FUNCTION CALL is raised.


DRAW statement
DRAW gml_string
--------------
In graphics mode, draws the shape specified by 'gml_string'. 'gml_string' must
be a string-valued expression in Graphics Macro Language (GML). 
GML reference:
Movement commands have the form 
    [B][N] movement
where the default is to move and draw; the optional prefixes mean:
    B       move but do not plot
    N       return to original point after move
and 'movement' is one of:
    Un      up n steps
    Ln      left n steps
    Dn      down n steps
    Rn      right n steps
    En      up+right n steps
    Fn      down+right n steps
    Gn      down+left n steps
    Hn      up+left n steps
    M{+|-}x,{+|-|}y
            move (x,y) steps
    Mx,y    move to view region coordinates x,y  
where 'n','x','y' must be integers in [0, 9999].
Scale commands are:
    Sn      sets the step size to n/4. The default step size is 1 pixel.  
            'n' must be an integer in [1, 255]
    TAn     sets the angle to n degrees. The default angle is 0 degrees.
            'n' must be an integer in [-360, 360]
    An      sets the angle to 0 for n=0, 90 for n=1, 180 for n=2, 270 for n=3.    
            'n' must be an integer in [0, 3]
Colour commands:    
    Cn      sets the colour attribute to n. See COLOR.
    Pn,b    flood fills with attribute n and boundary attribute b. See PAINT.
Subroutine command:
    Xs      execute substring. 's' is one of the following:
            -   a string variable name followed by semicolon (;)
            -   the result of VARPTR$() on a string variable
Numeric variables 'n','x','y','b' in the commands above can be:
    -   an integer literal e.g. "100"
    -   a numeric variable name preceded by = and followed by ; e.g. "=name;"
    -   the result of VARPTR$() on a numeric variable, preceded by =.               
NOTES:
-   CLS resets the step size to 1 pixel, angle to 0 degrees and position to the
    centre of the view region.                 
ERRORS:
-   If 'gml_string' has a numeric value, TYPE MISMATCH is raised.
-   If 'gml_string' has errors in the GML, ILLEGAL FUNCTION CALL is raised.
-   If a variable in the gml_string is of incorrect type, TYPE MISMATCH.


EDIT statement
EDIT line_number
--------------
Displays the specified program line with the cursor positioned for editing.
'line_number' must be a line that exists in the program, or a period (.) to 
indicate the last line stored.
ERRORS:
-   If no line_number is specified, raises UNDEFINED LINE NUMBER.
-   If more characters are written after the line number, raises ILLEGAL 
    FUNCTION CALL.
-   If 'line_number' is not in [0,65529], raises ILLEGAL FUNCTION CALL.    
-   If the specified line number dos not exist, raises UNDEFINED LINE NUMBER.


ELSE statement
ELSE [anything]
--------------
Unless part of an IF statement on the same line, anything after ELSE is ignored
in the same way as after the apostrophe (') or :REM. No colon (:) preceding 
the ELSE statement is necessary. See IF for normal usage.


END statement
END
-------------
Closes all files, stops program execution and returns to interactive mode.
No message is printed. It is possible to resume execution at the next statement
using CONT.


ENVIRON statement
ENVIRON command_string
-----------------
Sets a shell environment parameter. 'command_string' must be a string-valued
expression of one of the following forms:
    "PARAMETER=VALUE"   to set PARAMETER to VALUE
    "PARAMETER="        to unset PARAMETER
ERRORS:
-   If 'command_string' has a numeric value, TYPE MISMATCH is raised.
-   If 'command_string' is not of the required form, ILLEGAL FUNCTION CALL is 
    raised.


ENVIRON$ function    
value = ENVIRON$(x)
--------------------
Returns an environment parameter. 'x' is an expression.
If 'x' has a string value, returns the value for the parameter 'x' or the empty
string if no parameter with the name 'x' is set.
If 'x' has a numeric value, it must be in [1, 255]. Returns the 'x'th entry in 
the environment table.
ERRORS:
-   If 'x' is the empty string, raises ILLEGAL FUNCTION CALL.
-   If 'x' is a number not in [1,255], raises ILLEGAL FUNCTION CALL.
-   If 'x' is a number not in [-32768,32767], raises OVERFLOW.


EOF function
is_at_end = EOF(file_num) 
------------
Returns -1 if file with number 'file_num' has reached end-of-file; 0 otherwise.
The file must be open in INPUT or RANDOM mode. EOF(0) returns 0.
ERRORS:
-   If 'file_num' is a number not in [0,255], raises ILLEGAL FUNCTION CALL.
-   If 'file_num' is a number not in [-32768,32767], raises OVERFLOW.
-   If 'file_num' is not 0 or the number of an open file, raises 
    BAD FILE NUMBER.
-   If file with number 'file_num' is in OUTPUT or APPEND mode, raises 
    BAD FILE MODE.


ERASE statement
ERASE array_0 [, array_1 [, ...] ] 
---------------
Disallocates arrays to allow them to be re-dimensioned. The data stored in the
array is lost. 'array_0', ... are names of existing arrays. The names must be
specified without brackets.
NOTES:
-   If an error occurs, the arrays named before the error occurred are erased.
ERRORS:
-   If no array names are given, raises SYNTAX ERROR.
-   If 'array_0', ... does not exist, raises ILLEGAL FUNCTION CALL.


ERDEV function
zero = ERDEV
--------------
Returns 0. No brackets.
NOTES:
-   In GW-BASIC, returns the value of a device error. This is not implemented.


ERDEV$ function
empty = ERDEV$
---------------
Returns the empty string. No brackets.
NOTES:
-   In GW-BASIC, the device name of a device error. This is not implemented.


ERL function
error_line = ERL
------------
Returns the line number where the last error was raised. If the error was 
raised in interactive mode, returns 65535. If no error has been raised, 
returns 0. No brackets.


ERR function
error_code = ERR
------------
Returns the number of the last error. If no error has been raised, returns 0.
No brackets.
NOTES:
-   If the last error was a SYNTAX ERROR in interactive mode, returns 0.


ERROR statement
ERROR error_number
---------------
Raises the error with number 'error_number'. 'error_number' is an expression 
with a numeric value. 
ERRORS:
-   If 'error_number' is a string value, raises TYPE MISMATCH.
-   If 'error_number' is not in  [-32768, 32767], raises OVERFLOW.
-   If 'error_number' is not in [1,255], raises ILLEGAL FUNCTION CALL.


EXP(x) function
---------------
Returns the exponential of 'x', i.e. e to the power 'x'. 'x' must be a number-
valued expression. 
NOTES:
-   Unless BASIC is run with the --double option, EXP(x) returns a single-
    precision value.
-   Exp sometimes differs in the least significant digit from GW-BASIC. For 
    large values of 'x', the difference may be 3 digits.
ERRORS:
-   If 'x' has a string value, raises TYPE MISMATCH.
-   If 'x' is larger than the natural logarithm of the maximum single-precision
    value, raises OVERFLOW.


EXTERR function
zero = EXTERR(x)
---------------
Returns 0. 'x' must be a number-valued expression in [0, 3].
NOTES:
-   In GW-BASIC, EXTERR returns extended error information from MS-DOS. 
    This is not implemented.
ERRORS:
-   If 'x' is a string value, raises TYPE MISMATCH.
-   If 'x' is not in [-32768, 32767], raises OVERFLOW.
-   If 'x' is not in [0,3], raises ILLEGAL FUNCTION CALL.


FIELD statement
FIELD [#] file_number [, width_0 AS name_0 [, width_1 AS name_1 [, ...] ] ]
---------------
Maps variables to the random-access record buffer. The record buffer is a 
region of memory of length defined by the OPEN statement; the default record
length is 128 bytes. The FIELD statement associates a portion of this region to
one or more fixed-length string variables, so that the value of these strings
is whatever happens to be in the record buffer at that location. 
'file_number' is a numeric expression that yields the number of an open random-
access file. The # is optional and has no effect. 'width_0' is a numeric 
expression giving the length of the first string variable; 'name_0' is a valid 
string variable name, and so on for further variables. A FIELD statement 
without any variables specified has no effect.
A FIELD statement on the same file will specify an alternative mapping of the 
same file buffer; all mappings will be in effect simultaneously.
A subsequent assignment or LET or MID$ statement on 'name_0', ... will dis-
associate the string variable from the field buffer. Use LSET or RSET to change
values in the field buffer. Use GET to read values from the file into the field
buffer, changing the variables. Use PUT to write the field buffer to the file.
ERRORS:
-   If 'file_number' is not in [0,255], raises ILLEGAL FUNCTION CALL.
-   If 'file_number' is not the number of an open file, raises
    BAD FILE NUMBER.
-   If 'file_number' is open under a mode other than RANDOM, raises
    BAD FILE MODE.
-   If the statement ends in a comma, raises MISSING OPERAND.
-   If no file number is specified, raises MISSING OPERAND.
-   If the lengths in a FIELD statement add up to a number larger than the 
    record length of the field buffer, FIELD OVERFLOW is raised.
-   If 'name_0', ... specify a non-string variable, raises TYPE MISMATCH.


FILES statement
FILES path_and_filter
---------------
Displays the files fitting the specified filter in the specified directory. If
'path_and_filter' is not specified, displays all files in the current working 
directory. If specified, 'path_and_filter' is a string-valued expression that
consists of two optional parts: the first part is the path to the directory; 
the second part is the filename filter. The file part is a path list separated
by backslashes (\) as in MS-DOS. The filename filter consists of file name
parts and the wildcards ?, matching any character but not the \ or .; and the 
* matching any series of characters excluding . or \. If specified, a filter
will only match MS-DOS style 8.3 all-uppercase filenames. If all files in a 
specified directory are required, end the directory name with a backslash \.
The path directories, however, can be case sentitive and longer according to
the host OS's standards.
ERRORS:
-   If 'path_and_filter' has a numeric value, TYPE MISMATCH is raised.
-   If 'path_and_filter' is the empty string, BAD FILE NAME is raised.
-   If the specified filter does not match any files, FILE NOT FOUND is raised.


FIX function
whole = FIX(number)
------------
Returns 'number' truncated towards zero.    
'number' must be a numeric-valued expression.
NOTES:
-   While FIX truncates towards zero (i.e. removes the fractional part), INT
    truncates towards negative infinity. For negative 'x', FIX(x)-INT(x)==1.
ERRORS:
-   If 'number' is a string-valued expression, TYPE MISMATCH is raised.

 
FOR statement
FOR loop_var = start TO stop [STEP step]
----------------------------------------
Initiates a FOR--NEXT loop. 'loop_var' is a valid numeric variable name. 
'start', 'stop' and 'step' are number-valued expressions. 
Initially, 'loop_var' is set to 'start' Then, the statements between the FOR 
statement and the NEXT statement are executed and 'loop_var' is incremented by
'step' (if 'step' is not specified, by 1). This is repeated until 'loop_var' 
has become greater than or equal to 'stop'. Execution then continues at the 
statement following NEXT.
ERRORS:
-   If no NEXT statement is found to match the FOR statement, FOR WITHOUT NEXT
    is raised at the FOR statement.
-   If 'loop_var' is a string name or 'start','stop','end' are string-valued,
    TYPE MISMATCH is raised.
        

FRE function
free_mem = FRE(x)
------------
Returns the available model memory. 'x' is an expression. If 'x' is number-
valued, it is ignored. If 'x' is string valued, garbage collection is performed
before returning available model memory.


GET statement   (random-access files)
GET [#] file_number [, record_number]
-------------
Read a record from the random-access file 'file_number' at position
'record_number'. 'file_number' is a numeric expression that yields the number 
of an open random-access file. The # is optional and has no effect. 
'record_number' is a numeric expression that gives a number between 1 and 
33554432 (2^25), inclusive, and is interpreted as the record number. 
The record can be accessed through the FIELD variables, or through INPUT$,
 INPUT or LINE INPUT.
NOTES:
-   If the record number is beyond the end of the file, the file buffer is 
    filled with null bytes.
ERRORS:
-   If 'record_number' is not in [1, 33554432], raises BAD RECORD NUMBER.
-   If 'file_number' is not in [0,255], raises ILLEGAL FUNCTION CALL.
-   If 'file_number' is not the number of an open file, raises
    BAD FILE NUMBER.
-   If 'file_number' is open under a mode other than RANDOM, raises
    BAD FILE MODE.
-   If 'file_number' is not specified, raises MISSING OPERAND.
    

GET statement   (communications)
GET [#] com_file_number, [, number_bytes]
-------------
Read 'number_bytes' bytes from the communications buffer opened under file 
number 'com_file_number'. 'number_bytes' is a numeric expression between 1
and the COM buffer length, inclusive.
The record can be accessed through the FIELD variables but not through INPUT,
 INPUT$ and LINE INPUT.
NOTES:
-   If 'bytes' is 32768 or greater, GW-BASIC hangs (tries to read that many 
    bytes?). This is not implemented in PC-BASIC 3.23.
-   In GW-BASIC, DEVICE I/O ERROR is raised for overrun error, framing error,
    and break interrupt. DEVICE FAULT is raised if DSR is lost during I/O. A
    PARITY ERROR is raised if parity is enabled and incorrect parity is 
    encountered. This is according to the manual; it is untested.
ERRORS:
-   If 'bytes' is less than 1, raises BAD RECORD NUMBER
-   If 'bytes' is less than 32768 and greater than the COM buffer length,
    raises ILLEGAL FUNCTION CALL
-   If 'com_file_number' is not specified, raises MISSING OPERAND.
-   If 'com_file_number' is not in [0,255], raises ILLEGAL FUNCTION CALL.
-   If 'com_file_number' is not the number of an open file, raises
    BAD FILE NUMBER.
-   If the serial input buffer is full, i.e. LOF(com_file_number) == 0, and 
    LOC(com_file_number)==255, raises COMMUNICATION BUFFER OVERFLOW
-   If the carrier drops during GET, hangs until a break key is entered.
        
    
GET statement   (graphics)
GET (x0,y0)-(x1,y1), array_name
-------------
Stores a rectangular area of the graphics screen in an array. 'array_name' must
be the name of a numeric array dimensioned with enough space to store the area. 
The area stored is a rectangle parallel to the screen edges, bounded by the 
top-left and bottom-right coordinates 'x0','y0' and 'x1','y1'. The area is such
that these points are inside it. 'x0', ... 'y1' are number-valued expressions. 
The image stored in the array can then be put on the screen using PUT. For the 
purposes of GET, any array is considered a string of bytes. The byte size of an
array can be calculated as number_elements * byte_size with bytes_size equal to
2 for integers (%), 4 for single (!) and 8 for double (#). Array byte size for
string is 3, but string arrays are not allowed in GET. For calculating the 
number of elements, keep in mind that OPTION BASE 0 is the default; in which 
case an array with maximum index 10 has 11 elements. This works trough in
multidimensional arrays. 
Format in array:
    0,1 number of x pixels, unsigned int. In SCREEN 1, this value is doubled.
    2,3 number of y pixels, unsigned int.
    4...pixel data (many bytes)
Pixel data format:
    Data is arranged in 2-byte words. The first 16-bit word holds the bit 0 of 
    the first 16 pixels on the top row. The second word holds the second bit,
    etc. Data is word-aligned at the end of each row. Thus, in a screen mode 
    with 4 bits per pixel, the first row takes at least 8 bytes (4 words), even
    if it consists of only one pixel. The number of bits per pixel depends on 
    the SCREEN mode.
ERRORS:
-   If the array does not exist, raises ILLEGAL FUNCTION CALL.
-   If 'array_name' refers to a string array, raises TYPE MISMATCH.
-   If the area is too large for the array, raises ILLEGAL FUNCTION CALL.  
-   If 'x0', ... 'y1' are string expressions, raises TYPE MISMATCH.
-   If 'x0', ... 'y1' are not in [-32768, 32767], raises OVERFLOW.
-   If 'x0', ... 'y1' are outside the current VIEW or WINDOW, raises
    ILLEGAL FUNCTION CALL
    

GOSUB statement
GOSUB line_number [ anything ]
---------------
Jumps to a subroutine at 'line_number'. The next RETURN satement jumps back to
the statement after GOSUB. Anything after 'line_number' until the end of the 
statement is ignored. If executed in interactive mode, GOSUB enters runmode and
the following RETURN returns execution to the direct line.
'line_number' must be an existing line number literal. Further characters on 
the line are ignored until end of statement.
NOTES:
-   If no RETURN is encountered, no problem.
ERRORS:
-   If 'line_number' does not exist, raises UNDEFINED LINE NUMBER.
-   If 'line_number' is greater than 65529, only the first 4 characters are 
    read (e.g. 6553)


GOTO statement
GOTO line_number [anything]
--------------
Jumps to 'line_number'.  Anything after 'line_number' until the end of the 
statement is ignored. If executed in interactive mode, GOTO enters runmode and
the following RETURN returns execution to the direct line.
'line_number' must be an existing line number literal. Further characters on 
the line are ignored until end of statement.
ERRORS:
-   If 'line_number' does not exist, raises UNDEFINED LINE NUMBER.
-   If 'line_number' is greater than 65529, only the first 4 characters are 
    read (e.g. 6553)
    

HEX$ function
hex_repr = HEX(x)
----------------
Returns a string with the hexadecimal representation of 'x'. 'x' must be a 
number-valued expression between -32768 and 65535, inclusive. Values for 
negative 'x' are shown as two's-complement. 
ERRORS:
-   If 'x' is not in [-32768, 65535], OVERFLOW is raised.
-   If 'x' has a string value, TYPE MISMATCH is raised.


IF statement
IF truth_value [,] { THEN | GOTO } [ statements_1 | line_number_1 [anything] ]
    [ ELSE [ statements_0 | line_number_0 [anything] ] ]
------------
If 'truth_value' is non-zero, executes statements_1 / jumps to line_number_1. 
If it is zero, executes statements_0 or jumps to line_number_1. 'truth_value' 
is a number-valued expression. The comma is optional and ignored. 
'line_number_0' and 'line_number_1' are valid existing line numbers. 
Statements 'statements_0' and 'statements_1' can be compound statements with
one or more colons (:) separating single statements. The compound statements 
can contain nested IF..THEN..ELSE statements. ELSE clauses are optional; they
are bound to the innermost free IF statement if nested. Additional ELSE 
clauses that have no matching IF are ignored. All clauses must be on the same 
program line.
NOTES:
-   THEN and GOTO are interchangeable; which one is chosen is independent
    of whether a statement or a line number is given. GOTO PRINT 1 is fine.
-   As in GOTO, anything after the line number is ignored.
-   If 'truth_value' has a string value, raises TYPE MISMATCH.
    
    
INKEY$ function 
---------------
Returns one keypress from the keyboard buffer. If the keyboard buffer is 
empty, returns the empty string. Otherwise, the return value is either a one
character string or a two-character string of which the first is CHR$(0) and
the second a keyboard scancode.
The hex values for keyboard scancodes returned by INKEY$ are:
    <UP>            48
    <DOWN>          50
    <RIGHT>         4D
    <LEFT>          4B
    <INSERT>        52
    <DELETE>        53
    <HOME>          47
    <END>           4F
    <PAGEUP>        49
    <PAGEDOWN>      51
    <F1>            3B
    <F2>            3C
    <F3>            3D
    <F4>            3E
    <F5>            3F
    <F6>            40
    <F7>            41
    <F8>            42
    <F9>            43
    <F10>           44
    <PRINT>         37
    <CTRL+RIGHT>    74
    <CTRL+LEFT>     73
    <CTRL+HOME>     77
    <CTRL+END>      75
    <CTRL+PAGEUP>   84
    <CTRL+PAGEDOWN> 76
    <CTRL+2>        03
    <CTRL+9>        84
    <CTRL+F2>       5F
    <CTRL+F3>       60



INP function
code = INP(x)
------------
If 'x'==&H60, returns the keyboard scancode for the last key pressed
'x' is a numeric expression with a value between 0 and 65535, inclusive.
Returns zero otherwise. 
The scancodes returned by INP(&H60) are listed below. If the key is currently
down, the scancode is returned; if it has been released, the scancode is 
incremented by 128.
Scancodes returned by INP(&H60):
    <ESC>       01
    <1>         02
    <2>         03
    <3>         04
    <4>         05
    <5>         06
    <6>         07
    <7>         08
    <8>         09
    <9>         0A
    <0>         0B
    <->         0C
    <=>         0D
    <BACKSPACE> 0E
    <TAB>       0F
    <q>         10
    <w>         11
    <e>         12
    <r>         13
    <t>         14
    <y>         15
    <u>         16
    <i>         17
    <o>         18
    <p>         19
    <[>         1A
    <]>         1B
    <ENTER>     1C
    <CTRL>      1D
    <a>         1E
    <s>         1F
    <d>         20
    <f>         21
    <g>         22
    <h>         23
    <j>         24
    <k>         25
    <l>         26
    <;>         27
    <'>         28
    <`>         29
    <LSHIFT>    2A
    <#>         2B
    <z>         2C
    <x>         2D
    <c>         2E
    <v>         2F
    <b>         30
    <n>         31
    <m>         32
    <,>         33
    <.>         34
    </>         35
    <RSHIFT>    36
    <PRTSC>     37
    <SYSRQ>     37
    <ALT>       38
    <SPACE>     39
    <CAPSLOCK>  3A
    <F1>        3B
    <F2>        3C
    <F3>        3D
    <F4>        3E
    <F5>        3F
    <F6>        40
    <F7>        41
    <F8>        42
    <F9>        43
    <F10>       44
    <NUMLOCK>   45
    <SCROLLOCK> 46
    <HOME>      47
    <UP>        48
    <PGUP>      49
    <KEYPAD ->  4A
    <LEFT>      4B
    <KEYPAD 5>  4C
    <RIGHT>     4D
    <KEYPAD +>  4E
    <END>       4F
    <DOWN>      50
    <PGDN>      51
    <INS>       52
    <DEL>       53
NOTES:
-   In GW-BASIC, returns a byte read from machine port 'x'. This is not 
    implemented in PC_BASIC 3.23, except for the common use case of INP(&H60).
ERRORS:
-   If 'address' is not in [-32768, 65535], OVERFLOW is raised.
-   If 'address' has a string value, TYPE MISMATCH is raised.
        

INPUT statement (screen)
INPUT [;] [ prompt {;|,} ] var_0 [, var_1 [, ... ] ]
---------------
Prints 'prompt' to the screen and waits for the user to input values for var_0,
 ... . 'prompt' is a string literal. 'var_0', ... are variable names or 
fully indexed array elements.  The semicolon before the prompt, if present, 
stops a newline from being printed after the values have been entered.
If the prompt is followed by a semicolon, it is printed with a trailing ?. If 
the prompt is followed by a comma, no question mark is added. 
NOTES:
-   Values entered must be separated by commas. Leading and trailing whitespace
    is discarded.
-   String values can be entered with or without double quotes ("). 
-   If a string with a comma, leading or trailing whitespace is needed, 
    quotes are the only way to enter it. 
-   Between a closing quote and the comma at the end of the entry, only white-
    space is allowed.    
-   If quotes are needed in the string itself, the first character must be 
    neither a quote nor whitespace. It is not possible to enter a string that
    starts with a quote through INPUT.
-   If a given 'var_n' is a numeric variable, the value entered must be a valid
    number literal.
-   Characters beyond the 255th character of the screen line are discarded.    
ERRORS:
-   If the value entered for a numeric variable is not a valid numeric literal,
    or the number of values entered does not match the number of variables in 
    the statement,
    ?REDO FROM START is printed and all values must be entered again. 
-   A SYNTAX ERROR that is caused after the prompt is printed is only raised
    after the value shave been entered. No values are stored.
    

INPUT# statement (text files, devices, or random-access files)
INPUT # file_num, var_0 [, var_1 [, ...] ]
----------------
Reads string or numeric variables from a text file, device, or the FIELD buffer
of a random access file. 'file_num' must be the number of a file open in 
INPUT mode or a device or random-access file open in RANDOM mode. 'var_0', ... 
are variable names or fully indexed array elements.   
NOTES:
-   The # is mandatory. There may or may not be whitepace between INPUT and #.        
-   String values can be entered with or without double quotes ("). 
-   Numeric values are terminated by space, LF, CR, comma.
-   Unquoted strings are terminated by LF, CR, comma.
-   Quoted strings are terminated by the closing quote.
-   Any entry is terminated by end-of-file &h1a or its 255th character.
-   Leading and trailing whitespace is discarded.
-   If the entry cannot be converted to the requested type, a zero value is
    returned.
ERRORS:
-   If input is requested after the end of a text file has been reached or an
    EOF char has been encountered, raises INPUT PAST END.
-   If the last character of the field buffer is read, raises FIELD OVERFLOW.     
-   If 'file_num' is not an open file, raises BAD FILE NUMBER.
-   If 'file_num' is less than zero, raises ILLEGAL FUNCTION CALL.
-   If 'file_num' is greater than 32767, raises OVERFLOW.
-   If 'file_num' is not open for INPUT or RANDOM, raises BAD FILE MODE.
-   If 'file_num' is a string, raises TYPE MISMATCH.
    

INPUT$ function
chars = INPUT$(num_chars [, [#] file_num])
---------------
Returns a string of 'num_chars' characters from the keyboard or a file. 
'num_chars' must be a number-valued expression between 1 and 255, inclusive.
If 'file_num' is provided, reads the string from a text file. 'file_num' must
be a number valued expression that returns the number of a text file opened in
 INPUT mode. The hash is optional and has no effect.
NOTES:
-   This is a blocking read. It will wait for characters if there are none 
    in the buffer.
-   All control characters except <CTRL+BREAK>, <CTRL+SCROLLOCK> and <PAUSE> 
    are passed to the string by INPUT$. <CTRL+BREAK> and <CTRL+SCROLLOCK> break
    execution whereas <PAUSE> halts until aother key is pressed (and not read).
ERRORS:
-   If 'num_chars' is not in [-32768, 32767], raises OVERFLOW.
-   If 'num_chars' is not in [1, 255], raises ILLEGAL FUNCTION CALL.
-   If 'file_num' is not an open file, raises BAD FILE NUMBER.
-   If 'file_num' is less than zero, raises ILLEGAL FUNCTION CALL.
-   If 'file_num' is greater than 32767, raises OVERFLOW.
-   If 'file_num' is not open for INPUT, raises BAD FILE MODE.
-   If 'num_chars' or 'file_num' are strings, raises TYPE MISMATCH.
    
    
INSTR function
position = INSTR([start,] parent, child)
--------------
Returns the location of the first occurrence of the substring 'child' in 
'parent'. 'parent' and 'child' must be string-valued expressions. If 'start' is
provided, it must be a number-valued expression between 1 and 255, specifying
the starting position from where to look; if not specified, the search starts 
at character 1.
NOTES:
-   If 'child' is not a substring of 'parent' occurring at or before 'start', 
    INSTR returns 0.
ERRORS:
-   If 'start' is not in [-32768, 32768], raises OVERFLOW.
-   If 'start' is not in [1, 255], raises ILLEGAL FUNCTION CALL.
-   If 'start' has a string value or 'parent' or 'child' have number values, 
    raises TYPE MISMATCH.


INT function
whole = INT(number)
------------
Returns 'number' truncated towards negative infinity.    
'number' must be a numeric-valued expression.
NOTES:
-   While FIX truncates towards zero (i.e. removes the fractional part), INT
    truncates towards negative infinity. For negative 'x', FIX(x)-INT(x)==1.
ERRORS:
-   If 'number' is a string-valued expression, TYPE MISMATCH is raised.
 

IOCTL statement
IOCTL [#] file_num, control_string
---------------
Raises ILLEGAL FUNCTION CALL.
NOTES:
-   In GW-BASIC, IOCTL send a control string to a device. This is not 
    implemented in PC-BASIC 3.23.
ERRORS:
-   If 'file_num' is not an open file, raises BAD FILE NUMBER.
-   If 'file_num' is not in [-32768, 32767], raises OVERFLOW.
-   If 'file_num' has a string value, raises TYPE MISMATCH.
-   Otherwise, raises ILLEGAL FUNCTION CALL


IOCTL$ function
result = IOCTL$([#] file_num)
---------------
Raises ILLEGAL FUNCTION CALL.
NOTES:
-   In GW-BASIC, IOCTL$ reads the reply to IOCTL from a device. This is not 
    implemented in PC-BASIC 3.23.
ERRORS:
-   If 'file_num' is not an open file, raises BAD FILE NUMBER.
-   If 'file_num' is not in [-32768, 32767], raises OVERFLOW.
-   If 'file_num' has a string value, raises TYPE MISMATCH.
-   Otherwise, raises ILLEGAL FUNCTION CALL

    
KEY statement (string macro control)
KEY { ON | OFF | LIST }
-------------
Turns string macros ON or OFF; if LIST is specified, produces a list of
the 10 function keys with the string macros defined for those keys. Special 
characters are represented by their symbol equivalent in the loaded codepage;
some characters get a special representaation. E.g. chr$(13) is represented 
as a back arrow. 


KEY statement (string macro definition)
KEY key_id, string_value
-------------
Defines the string macro for key 'key_id'. 'key_id' must be a number-valued 
expression in the range 1--10, inclusive. 'string_value' must be a string-
valued expression. Only the first 15 caracters of 'string_value' are stored.
NOES:
-   IF 'key_id' is not in the range [1, 10], the statement is interpreted as an
    event trapping key definition (see below).
ERRORS:
-   If 'key_id' is not in [-32768, 32767], raises OVERFLOW.
-   If 'key_id' is not in [1, 255], raises ILLEGAL FUNCTION CALL.
-   If 'key_id' has a string value, raises TYPE MISMATCH.


KEY statement (event trapping control)
KEY ( key_id ) { ON | OFF | STOP } 
-------------
Controls event trapping of the key with identifier 'key_id'. If ON is specified
event trapping is switched on; if OFF, off. STOP suspends event trapping until 
another KEY() ON is executed. Up to one event can be triggered during 
suspension, provided that event handling was switched on prior to suspension. 
he event triggered during suspension is handled immediately after the next ..ON
statement.
'key_id' must be a number-valued expression in the range 1--20, inclusive. 
Keys 1--10 are F1--F10. Keys 11--14 are:
    11  <UP>
    12  <LEFT>
    13  <RIGHT>
    14  <DOWN>
Keys 15 to 20 are defined using the event trapping KEY definition statement
as described below.    
ERRORS:
-   If 'key_id' is not in [-32768, 32767], raises OVERFLOW.
-   If 'key_id' is not in [0, 20], raises ILLEGAL FUNCTION CALL.
-   If 'key_id' has a string value, raises TYPE MISMATCH.
 

KEY statement (event trapping key definition)
KEY key_id, two_char_string
-------------
Defines the key to trap for 'key_id'. 'key_id' must be a number-valued 
expression in the range 15--20, inclusive. 'string_value' must be a string-
valued expression of length 2. The first character is interpreted as a modifier
while the second character is interpreted as a scan code. See INP for scan
codes. Modifiers are:
    &h80    Extended
    &h40    <CAPSLOCK>
    &h20    <NUMLOCK>
    &h08    <ALT>
    &h04    <CTRL>
    &h02    <SHIFT> (either side)
    &h01    <SHIFT> (either side)
NOTES:
-   If 'key_id' is not in [15,20], no error is raised, but strange things can 
    happen in GW-BASIC: screen anomalies and crashes suggestive of unintended
    memory access. This is not implemented in PC-BASIC: such values are 
    ignored.
-   If 'key_id' is in 1--10, the statement is interpreted as a string macro
    definition, see above.
ERRORS:
-   If 'key_id' is not in [-32768, 32767], raises OVERFLOW.
-   If 'key_id' is not in [1, 255], raises ILLEGAL FUNCTION CALL.
-   If 'key_id' has a string value, raises TYPE MISMATCH.
-   If 'two_char_string' is longer than two, raises ILLEGAL FUNCTION CALL. 
-   If 'two_char_string' has a numeric value, raises TYPE MISMATCH.


KILL statement
KILL file_path
--------------
Deletes a file. 'file_path' must be a string-valued expression that specifies a
valid path to an existing file with MS-DOS path separators (\). The extension 
must be specified: no default extensions are assumed. KILL will first attempt 
to delete a file with the name exactly as provided; this is case-sensitive if
the file system is. If such a file does not exist, KILL attempts to delete the
UPPERCASE 8.3 variant of the file name.  
ERRORS:
-   If the file 'file_path' is open, raises FILE ALREADY OPEN
-   If the file or path 'file_path' does not exist, raises FILE NOT FOUND
-   If the user has no write permission, raises PERMISSION DENIED 
-   If a syntax error occurs after the closing quote, the file is removed 
    anyway.
-   If 'file_path' has a number value, raises TYPE MISMATCH.


LCOPY statement
LCOPY num
---------------
Does nothing. 'num' is a number-valued expression between 0 and 255, inclusive.
NOTES:
-   This statement does nothing in GW-BASIC. Presumably, it is left over from a
    statement in older versions of MS Basic that would copy the screen to the 
    printer.
ERRORS:
-   If 'num' is not in [-32768, 32767], raises OVERFLOW.
-   If 'num' is not in [0, 255], raises ILLEGAL FUNCTION CALL.
-   If 'num' has a string value, raises TYPE MISMATCH. 


LEFT$ function
child = LEFT$(parent, num_chars)
--------------
Returns the leftmost 'num_chars' characters of 'parent'. 'parent' must be a 
string-valued expression. 'num_chars' must be a numeric expression between 0 
and 255, inclusive. If 'num_chars' is zero or 'parent' is empty, LEFT$ returns
an empty string "". If 'num_chars' is greater than the length of 'parent', 
returns 'parent'.
ERRORS:
-   If 'num_chars' is not in [-32768, 32767], raises OVERFLOW.
-   If 'num_chars' is not in [0, 255], raises ILLEGAL FUNCTION CALL.
-   If 'num_chars' has a string value, raises TYPE MISMATCH.


LEN function
length = LEN(string)
--------------
Returns the number of characters in 'string'. 'string' is a string-valued
expression.
ERRORS:
-   If 'string' has a number value, raises TYPE MISMATCH.


LET statement
[LET] name = expression
-------------
Assigns the value of 'expression' to the variable or array element 'name'. 
'name' must be a valid variable name that may or may not already exist. The
type of 'expression' must match that of 'name': that is, all numeric types can 
be assigned to each other but strings can only be assigned to strings.
ERRORS:
-   If 'name' and 'expression' are not of matching types, raises TYPE MISMATCH.


LINE statement
LINE [(x0, y0)] - (x1, y1) [, [attr] [, [B [F]] [, pattern]]]
--------------
Draws a line or a box in graphics mode. If B is not specified, a line is drawn
from ('x0', 'y0') to ('x1', 'y1'), endpoints inclusive. If B is specified, a 
rectangle is drawn with sides parallel to the screen and two opposing corners 
specified by ('x0', 'y0') and ('x1', 'y1'). If the starting point is not given, 
the current graphics position is used as a staring point. LINE moves the 
current graphics position to ('x1', 'y1'). 'attr' must be a number-valued 
expression between 0 and 255, inclusive, which specifies the colour attribute 
of the line. If it is not given, the current attribute is used. If F is 
specified with B, the rectangle is filled with the specified attribute. F and
B may be separated by zero or more spaces. If 'pattern' is specified, it must 
be a number-valued expression between -32768 and 32767, inclusive. This is 
interpreted as a 16-bit binary pattern mask apllied to consecutive pixels in 
the line: a 1 bit indicates a pixel plotted; a 0 bit indicates a pixel left 
untouched. The pattern starts at the most significant bit, which is applied
to the topmost endpoint. 







MOTOR 


