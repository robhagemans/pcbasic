PC-BASIC 3.23 REFERENCE

This file is copyright (c) 2014 Rob Hagemans and licensed under a 
Creative Commons Attribution-ShareAlike 4.0 International License.


INTERACTIVE MODE
----------------
The screen is divided into 'logical lines' whose length can exceed the width
of the physical line. The logical line includes all the text on the line. If 
the line has been wrapped or broken by <CTRL+J>, the logical line extends 
into the next physical line. 
The following keys have a special effect:
<UP> or <CTRL+6>            Move the cursor up, except at line 1.
<DOWN> or <CTRL+->          Move the cursor down, except at line 24. Line 25
                            cannot be reached with the arrow keys. 
<LEFT> or <CTRL+]>          Move the cursor left. The left edge of the screen 
                            wraps around, except at line 1.
<RIGHT> or <CTRL+/>         Move the cursor right. The right edge of the 
                            screen wraps around, except at line 24.
<CTRL+LEFT> or <CTRL+B>     Move to the first letter of the previous word. A 
                            word consists of letters A-Z and figures 0-9.
<CTRL+RIGHT> or <CTRL+F>    Move to the first letter of the next word.
<TAB> or <CTRL+I>           Move the cursor to the next tab stop. Tab stops
                            are 8 columns wide.
<BACKSPACE> or <CTRL+H>     Delete the character left of the cursor, shift 
                            all further characters on the logical line one 
                            position to the left and change the attributes of 
                            those characters to the current attribute. At the 
                            left edge of the screen, this does the same as 
                            <DEL>.
<DEL> or <CTRL+BACKSPACE>   Delete the character at the cursor and shift all 
                            further characters one position to the left, 
                            changing attributes to current.
<ESC> or <CTRL+[>           Delete the current logical line
<CTRL+END> or <CTRL+E>      Delete all characters from the cursor to the end 
                            of the logical line.
<CTRL+BREAK> or <CTRL+C>    Jump to the first column of the next line, 
or <CTRL+SCROLL_LOCK>       without executing or storing the line under the 
                            cursor.
<ENTER> or <CTRL+M>         Execute or store the current screen line. The 
                            complete line on the screen is considered part of 
                            the command, including any text you did not type. 
                            A line starting with a number is stored as a 
                            program line.
<END> or <CTRL+N>           Move the cursor to the first position after the 
                            end of the logical line.
<HOME> or <CTRL+K>          Move the cursor to the top left of the screen.
<CTRL+HOME> or <CTRL+L>     clear the screen and move the cursor to the top 
                            left of the screen.
<CTRL+ENTER> or <CTRL+J>    Move to the first column of the next line, 
                            connecting the two lines into one logical line.
<CTRL+G>                    Beep.
<PAUSE> or <CTRL+NUM_LOCK>  Pause. Press another key to resume.
<CTRL+PRT_SC>               Echo screen output to the printer.
<SHIFT+PRT_SC>              Print the screen.
<INS> or <CTRL+R>           Toggle INSERT mode. In INSERT mode, characters  
                            are inserted rather than overwritten at the 
                            current location. If insertion causes the line to 
                            extend the physical screen width, the logical 
                            line extends onto the next line. Arrow keys exit 
                            INSERT mode.


PROGRAMS
--------
A program line is entered by starting a line with a line number. All program 
lines must have a line number. Line numbers range from 0 to 65535 inclusive.
It is not possible to enter a line number higher than 65529, but these can 
exist in loaded programs. Lines between 65530 and 65535 are not visible in 
the program's LIST.
Within one program line, statements are separated by colons (:). The maximum
length of a program line is 255 characters.
Programs can be saved to disk with SAVE and loaded with LOAD. A program can 
be started using RUN or GOTO.


RUNMODE
-------
When a program is started, the commands in the program are followed until the
program quits and returns to interactive mode or until user input is required.
In program mode, a few keys have immediate effect:
<PAUSE> or <CTRL+NUM_LOCK>  Pause execution. Press another key to resume.
<CTRL+BREAK>                Stop execution and return to interactive mode.
or <CTRL+SCROLL_LOCK>       A BREAK message is printed.


INPUT MODE
----------
If user input is required by the statements INPUT, LINE INPUT, or RANDOMIZE, 
BASIC goes into input mode. In input mode, keys have the same effect as in
interactive mode. However, the following keys have different effect:
<CTRL+BREAK> or <CTRL+C>    Stop execution and return to interactive mode.
or <CTRL+SCROLL_LOCK>       A BREAK message is printed.
<ENTER>                     Finish input and return to the previous mode.


ERROR CODES
-----------
1   NEXT without FOR
2   Syntax error
3   RETURN without GOSUB
4   Out of DATA
5   Illegal function call
6   Overflow
7   Out of memory
8   Undefined line number
9   Subscript out of range
10  Duplicate Definition
11  Division by zero
12  Illegal direct
13  Type mismatch
14  Out of string space
15  String too long
16  String formula too complex
17  Can't continue
18  Undefined user function
19  No RESUME
20  RESUME without error
21
22  Missing operand
23  Line buffer overflow
24  Device Timeout
25  Device Fault
26  FOR without NEXT
27  Out of paper
28
29  WHILE without WEND
30  WEND without WHILE
31--49
50  FIELD overflow
51  Internal error
52  Bad file number
53  File not found
54  Bad file mode
55  File already open
56
57  Device I/O error
58  File already exists
59--60
61  Disk full
62  Input past end
63  Bad record number
64  Bad file name
65
66  Direct statement in file
67  Too many files
68  Device Unavailable
69  Communication buffer overflow
70  Permission Denied
71  Disk not Ready
72  Disk media error
73  Advanced Feature
74  Rename across disks
75  Path/File access error
76  Path not found
77  Deadlock
Any error code that does not have a message associated to it will generate
the message "Unprintable error".


LITERALS
--------
String literals can be specified between double quotes. There is no escaping
mechanism. To include a double quote or a special character in a string, use
the CHR$() function.
Numeric literals:
  [{+|-}] [digits] [.] [digits] [ { {E|D} [{+|-}] [digits] | # | ! | % } ]
  &{H|h}hexadecimal_digits
  &[O|o]octal_digits
Trailing % is ignored, ! or # specify the type.
Examples of valid numeric literals:
  -1
  42
  42!
  42#
  1.3523523
  .235435
  -.3
  3.
  .         (this equals 0!)
  .e        (0!)
  .D        (0#)
  1.1e+7
  1.1d+7
  1e2
  1e-2
  &7
  &hffff
  &O20
Hexadecimal literals can be specified like &HFFFF. They must range between 
-&H7FFF and &HFFFF. &HFFFF = -&H1 = &H-1 .
Octal literals can be specified as &o777 or &777.


VARIABLES
---------
Variable names must start with a letter; all characters of the variable name
(except the type character) must be letters (A-Z), figures (0-9), or a dot (.)
Only the first 40 characters in the name are significant. Variable names must
not be identical to keywords -- roughly, statement or function names; more 
accurately, anything that has a defined keyword token, including such words as
TO but not, for instace, AS. There is no particular logic to this. For each 
name, four different variables may exist corresponding to the four types. 
That is, you can have A$, A%, A! and A# with different values. Which one of 
those is called A depends on the settings in DEFINT/DEFDBL/DEFSNG/DEFSTR. 
The default is A==A!. In addition, you can have arrays A$(), A%(), A!(), A#() 
which are separate from the scalar variables of the same name.


TYPES
-----
PC-BASIC recognises four variable types, distinguished by their type character
which is the last character of the variable's name:
char    type                    size
 $      string                  3 bytes plus allocated string space
 %      integer                 2 bytes 
 !      single-precision float  4 bytes
 #      double-precision float  8 bytes 
If the type character is not specified, the first letter of the name determines
the type through DEFINT/DEFSTR/DEFSNG/DEFDBL. Unless otherwise specified, all
variables are single-precision floats.
Internal representation:
-   Line numbers are two-byte unsigned little-endian.
-   Integers are two-byte signed little-endian two's complement ints.
-   Booleans are represented as 0 (FALSE); -1 or other non-zero (TRUE). 
-   Floats are represented in the Microsoft Binary Format (MBF).
Machine limits:
    Line numbers are in [0, 65529]. 65530-65535 are unused.
    Integers are in [-32768, 32767]. 
    Floats: largest 1.701412E+38; smallest 2.938726E-39
    Double-precision floats can hold more decimals but not larger or smaller 
    numbers.
    
    
ARRAYS
------
Arrays of any type can be generated. Arrays are indexed with round or square 
brackets; even mixing brackets is allowed. The following work: A[0] A(0) 
A(0] A[0). Multidimensional arrays are specified with commas: A(0,0) etc.
By default, arrays are counted from 0. This can be changed to 1 using 
 OPTION BASE 1. Arrays can be allocated using DIM. If all indices of the array
are 10 or less, arrays can be used without using the DIM command. The first 
referencing of the array (read or write) will automatically dimension it with 
a maximum index of 10 and the same number of indices as in the first 
referencing. To re-allocate an array, first the old array must be deleted 
through CLEAR or ERASE.


OPERATORS
---------
Order of precedence:    
    ^	Exponentiation
    -	Negation
    *	Multiplication  
    /	Floating-point Division   \   Integer division   MOD  Integer modulo
    +	Addition   - Subtraction
NOTE: Exponentiation is tighter bound than negation: -1^2 = -1 but (-1)^2 = 1.
Relational:
    =       Equal
    <> ><   Not equal
    <       Less than
    >       Greater than
    <= =<   Less than or equal
    >= =>   Greater than or equal
Boolean:
    NOT, AND, OR, XOR, EQV, IMP


ATTRIBUTES, PALETTES AND COLOURS
--------------------------------


INTERNAL REPRESENTATION OF NUMBERS AND THE MICROSOFT BINARY FORMAT
------------------------------------------------------------------


DEVICES
-------
PC-BASIC recognises the following DOS-style devices, which can be opened, input
to and output from much like normal files. 
device      allowed modes   description
SCRN:       OUTPUT          The screen. Output to SCRN: has largely the same 
                            effect as straight output using PRINT. A difference
                            is the WIDTH setting which is independent of the 
                            real screen width.
KYBD:       INPUT           The keyboard. Input read from KYBD: is not echoed 
                            to the screen. Special keys like arrow keys are
                            registered differently than when using INPUT or
                            INPUT$ straight (see the keyword reference).
LPT1:       OUTPUT          Parallel ports 1--3. These are usually used to 
LPT2:                       connect a printer. In PC-BASIC, output to the LPT
LPT3:                       ports can be redirected to a printer connected to 
                            the OS or to a text file. Direct access of the 
                            parallel port is not implemented.
COM1:       INPUT, OUTPUT,  Serial ports 1--2. In PC-BASIC 3.23, direct access
COM2:       APPEND, RANDOM  of the serial port is allowed; alternatively, i/o
                            can be redirected through a UNIX socket or a text
                            file.                   
CONS:       OUTPUT          The screen (console). Output to CONS is displayed 
                            directly at the cursor position when <ENTER> is 
                            pressed. It does not update the end-of-line value
                            for the interpreter, which means that it does not 
                            move with <BACKSPACE> or <DELETE> and is not 
                            stored in program lines if it appears beyond the 
                            end of the existing line. CONS: can be opened with
                            any access mode, but the effect is always to open 
                            it for OUTPUT. This device is not implemented in 
                            PC-BASIC 3.23.                             
                                                            

KEYWORD LIST
------------
Not all keywords are statements or functions; some parts of statement or 
function syntax are not keywords. The relevance of this is that keywords are 
not legal variable names. Therefore, you cannot name a variable TO! but you can
name it AS!. The keywords are here listed with the bytecode token used to 
represent them in a BASIC file.
 81 END     82 FOR     83 NEXT    84 DATA    85 INPUT   86 DIM     87 READ  
 88 LET     89 GOTO    8A RUN     8B IF      8C RESTORE 8D GOSUB   8E RETURN  
 8F REM     90 STOP    91 PRINT   92 CLEAR   93 LIST    94 NEW     95 ON  
 96 WAIT    97 DEF     98 POKE    99 CONT    9C OUT     9D LPRINT  9E LLIST  
 A0 WIDTH   A1 ELSE    A2 TRON    A3 TROFF   A4 SWAP    A5 ERASE   A6 EDIT  
 A7 ERROR   A8 RESUME  A9 DELETE  AA AUTO    AB RENUM   AC DEFSTR  AD DEFINT  
 AE DEFSNG  AF DEFDBL  B0 LINE    B1 WHILE   B2 WEND    B3 CALL    B7 WRITE  
 B8 OPTION B9 RANDOMIZE BA OPEN   BB CLOSE   BC LOAD    BD MERGE   BE SAVE      
 BF COLOR   C0 CLS     C1 MOTOR   C2 BSAVE   C3 BLOAD   C4 SOUND   C5 BEEP
 C6 PSET    C7 PRESET  C8 SCREEN  C9 KEY     CA LOCATE  CC TO      CD THEN  
 CE TAB(    CF STEP    D0 USR     D1 FN      D2 SPC(    D3 NOT     D4 ERL
 D5 ERR     D6 STRING$ D7 USING   D8 INSTR   D9 '       DA VARPTR  DB CSRLIN  
 DC POINT   DD OFF     DE INKEY$  E6 >       E7 =       E8 <       E9 + 
 EA -       EB *       EC /       ED ^       EE AND     EF OR      F0 XOR  
 F1 EQV     F2 IMP     F3 MOD     F4 \\
 FD81 CVI     FD82 CVS     FD83 CVD     FD84 MKI$    FD85 MKS$    FD86 MKD$
 FD8B EXTERR  FE81 FILES   FE82 FIELD   FE83 SYSTEM  FE84 NAME    FE85 LSET  
 FE86 RSET    FE87 KILL    FE88 PUT     FE89 GET     FE8A RESET   FE8B COMMON
 FE8C CHAIN   FE8D DATE$   FE8E TIME$   FE8F PAINT   FE90 COM     FE91 CIRCLE 
 FE92 DRAW    FE93 PLAY    FE94 TIMER   FE95 ERDEV   FE96 IOCTL   FE97 CHDIR 
 FE98 MKDIR   FE99 RMDIR   FE9A SHELL   FE9B ENVIRON FE9C VIEW    FE9D WINDOW
 FE9E PMAP    FE9F PALETTE FEA0 LCOPY   FEA1 CALLS   FEA5 PCOPY 
 FEA7 LOCK    FEA8 UNLOCK  FF81 LEFT$   FF82 RIGHT$  FF83 MID$    FF84 SGN    
 FF85 INT     FF86 ABS     FF87 SQR     FF88 RND     FF89 SIN     FF8A LOG   
 FF8B EXP     FF8C COS     FF8D TAN     FF8E ATN     FF8F FRE     FF90 INP   
 FF91 POS     FF92 LEN     FF93 STR$    FF94 VAL     FF95 ASC     FF96 CHR$   
 FF97 PEEK    FF98 SPACE$  FF99 OCT$    FF9A HEX$    FF9B LPOS    FF9C CINT  
 FF9D CSNG    FF9E CDBL    FF9F FIX     FFA0 PEN     FFA1 STICK   FFA2 STRIG  
 FFA3 EOF     FFA4 LOC     FFA5 LOF          
NOTES:
-   If PC-BASIC 3.23 is run with the --debug flag, the following additional 
    keyword is reserved, which is not present in standard versions of GW-BASIC:
        FEA4 DEBUG
    When the --debug flag is specified, variable names like DEBUG$ are not 
    allowed.
-   On the IBM PCjr's version of GW-BASIC, some additional these keywords were 
    present that are not implemented in PC-BASIC 3.23. They are:
        FEA4 NOISE   FEA6 TERM


ABS(x) function
---------------
Returns the absolute value of 'x'. 'x' is an expression with a numeric value.
If 'x' has a string value, ABS raises TYPE MISMATCH.


ASC(x) function
---------------
Returns the ASCII code for the first character of x. x is an expression with 
a string value.
ERRORS:
-   If 'x' has a numeric value, ASC raises TYPE MISMATCH.
-   If 'x' equals "", ASC raises ILLEGAL FUNCTION CALL.


ATN(x) function
---------------
Returns the inverse tangent of x. 'x' is a numeric-valued expression that gives 
the angle in radians. Unless BASIC is run with the --double option, ATN(x) 
returns a single-precision value.
NOTES:
-   ATN(x) differs in the least significant digit from GW-BASIC.
ERRORS:
-   If 'x' has a string value, ATN raises TYPE MISMATCH.


AUTO statement
AUTO [ { line_number | . } ] [, [increment]] 
--------------
Enter automatic line numbering mode (AUTO mode). In AUTO mode, line numbers 
are automatically generated when <ENTER> is pressed.
Line numbering starts at 'line_number', if specified. If . is specified, line 
numbering starts at the last program line that was stored. Otherwise, line
numbering starts at 10. 
Each next line number is incremented by 'increment', if specified. If a comma 
is used withoud specifying an increment, the last increment specified in an 
AUTO command is used. If not, increment defaults to 10.
If a program line exists at a generated line number, a '*' is shown after the 
line number. To avoid overwriting this line, leave it empty and press <ENTER>.
To exit AUTO mode, press <CTRL+BREAK> or <CTRL+C>. The line being edited at 
that point is not saved. BASIC will return to command mode, even if AUTO was 
run from a program line.
ERRORS:
-  If line_number is not an unsigned-integer value between 0 and 65529, 
   inclusive, SYNTAX ERROR is raised.
-  In AUTO mode, pressing <ENTER> on an empty line with number larger than 
   65519, UNDEFINED LINE NUMBER is raised.


BEEP statement
BEEP
--------------
Beeps at 800Hz for 0.25s.
ERRORS:
-   If a SYNTAX ERROR is raised, the beep is still produced.


BLOAD statement
BLOAD filename [, offset]
---------------
Raises ADVANCED FEATURE.
NOTES:
-  In GW-BASIC, BLOAD loads an image file into memory. 
   This is not implemented in PC-BASIC 3.23.   


BSAVE statement
BSAVE filename, offset, length
---------------
Raises ADVANCED FEATURE.
NOTES:
-  In GW-BASIC, BSAVE saves a region of memory to an image file. 
   This is not implemented in PC-BASIC 3.23.  


CALL statement
CALL address, variables
--------------
Raises ADVANCED FEATURE.
NOTES:
-  In GW-BASIC, CALL executes a machine language subroutine.
   This is not implemented in PC-BASIC 3.23.  


CALLS statement
CALLS name
------------
Raises SYNTAX ERROR.
NOTES:
-   This keyword is undocumented in GW-BASIC. When called with a numeric 
    variable name, it hangs the interpreter. When called with a string
    variable name, it raises TYPE MISMATCH. When called with a literal, it
    raises SYNTAX ERROR. This is not implemented in PC-BASIC 3.23.


CDBL(x) function
----------------
Converts the numeric-valued expression 'x' to a double-precision value.
ERRORS:
-  If 'x' has a string value, TYPE MISMATCH is raised.


CHAIN statement
CHAIN [MERGE] program [, [line_number_expr] [, [ALL] [, DELETE range]]]
---------------
Loads 'program' into memory and runs it, optionally transferring variables.
If 'line_number_expr' is specified, it must be a numeric-valued expression. It 
will be interpreted as a line number in the new program and execution will 
start from this line number. If 'line_number_expr' is negative, it will be 
interpreted as its two's-complement. 
If ALL is specified, all variables are transferred. If not, the variables 
specified in a COMMON statement are transferred. 
IF MERGE is specified, 'program' is merged into the existing program. To be 
able to use this, 'program' must be saved as ASCII.
If DELETE is specified, the 'range' of line numbers is deleted from the 
existing code before the merge. This is pointless without MERGE.
NOTES:
-   CHAIN preserves the OPTION BASE setting.
-   Only if ALL is specified, DEF FN definitions are preserved.
-   Only if MERGE is specified, DEFINT, DEFSTR, DEFSNG, DEFDBL definitions 
    are preserved.
ERRORS:
-   If MERGE is specified and 'program' was not saved in ASCII mode, 
    BAD FILE MODE is raised.
-   If a SYNTAX ERROR is raised by CHAIN, no lines are deleted and the new
    program is not loaded.
-   If a line number in 'range' is greater than 65529, SYNTAX ERROR is raised.
-   If the 'range' does not include any program lines stored, CHAIN
    raises ILLEGAL FUNCTION CALL.
-   If 'line_number_expr' does not evaluate to an existing line number in the
    new program, ILLEGAL FUNCTION CALL is raised but the load or merge is 
    being performed.


CHDIR statement
CHDIR pathname
---------------
Change the working directory to 'pathname'. 'pathname' is a string-valued 
expression which can be absolute or relative to the current path. 'pathname'
must be specified with MS-DOS path separators (\). CHDIR first looks for the
exact, case-sensitive (on Unix) path 'pathname'; if this does not exist then
an uppercase version truncated to 8.3 is attempted.
ERRORS:
-  If no matching path is found, PATH NOT FOUND is raised.
-  If 'pathname' is not string-valued, TYPE MISMATCH is raised.
-  If 'pathname' is empty, BAD FILE NAME is raised.


CHR$(x) function
----------------
Returns the character with ASCII code 'x'. 'x' must have a numeric value 
between 0 and 255 (inclusive). 
ERRORS:
-  If 'x' is a string value, TYPE MISMATCH is raised.
-  If 'x' is not -32768<=x<=32767, OVERFLOW is raised.
-  If 'x' is not 0<=x<=255, ILLEGAL FUNCTION CALL is raised.


CINT(x) function
----------------
Converts the numeric-valued expression 'x' to a signed integer.
ERRORS:
-  If 'x' is a string value, TYPE MISMATCH is raised.
-  If 'x' is not -32768<=x<=32767, OVERFLOW is raised.


CIRCLE statement
CIRCLE (x, y), radius [, [colour] [, [start] [, [end] [, aspect] ] ]
----------------
Draw an ellipse or ellipse sector. The midpoint of the ellipse is at 'x','y'.
'radius' is the radius, in pixels, along the long axis.
'colour' is the colour attribute.
If 'start' and 'end' are specified, a sector of the ellipse is drawn from 
'start' radians to 'end' radians, with zero radians the intersection with the 
right-hand x axis. If a negative value is specified, the arc sector is 
connected by a line to the midpoint.
'aspect' specifies, the ratio between the y radius and the x radius. If it is
not specified, the standard value for the SCREEN mode is used (see there), so
as to make the ellipse appear like a circle on the original hardware. 
NOTES: 
-  The rectangular pixels of some screen modes are currently not faithfully 
   reproduced by PC-BASIC 3.23, making default circles look like ellipses.
-  For 'aspect'<>1, the midpoint algorithm used does not pixel-perfectly 
   reproduce GW-BASIC's ellipses.
ERRORS:
-  In text mode (SCREEN 0), CIRCLE raises ILLEGAL FUNCTION CALL.
-  If 'start' or 'end' is not between 0 and 2pi, ILLEGAL FUNCTION CALL raised.
-  If the statement ends with a comma, MISSING OPERAND is raised.


CLEAR statement
CLEAR [expr] [, [mem_limit] [, stack_size] ]
---------------
Sets all variables to null. Closes all files. Clears all DEF FN functions. 
Clears all COMMON declarations. Turns off all sound. Resets music foreground.
Turns PEN and STRIG off. Clears all ON ERROR traps. Resets ERR and ERL to zero.
Disables all events. Resets the random number generator.
NOTES:
-  In GW-BASIC, 'mem_limit' specifies the upper limit of usable memory, and 
   'stack_size' specifies the amount of memory available to the stack and to
   string space. These are not implemented.
-  In GW-BASIC, If 'mem_limit' or 'expr' are too low, OUT OF MEMORY is raised.
-  The purpose of 'expr' is unknown.
ERRORS:
-  If 'mem_limit' or 'stack_size' equal 0, ILLEGAL FUNCTION CALL is raised.
-  If 'expr' is negative, ILLEGAL FUNCTION CALL is raised.
-  If 'expr','mem_limit','stack_size' are not in [-32768, 32767], OVERFLOW.


CLOSE statement
CLOSE [[#] file_1 [, [#] file_2 [, ...] ]
---------------
Closes files. 'file_1', 'file_2' etc are numeric-valued expressions yielding 
file numbers. If no file numbers are specified, all open files are closed.
The hash (#) is optional and has no effect.
NOTES:
-  If 'file_1' etc. is not an open file, no error is raised.
ERRORS:
-  If 'file_1' etc. is not in [-32768,32767], raises OVERFLOW.
-  If 'file_1' etc. is not in [0,255], raises ILLEGAL FUNCTION CALL.
-  If 'file_1' etc. is string-valued, TYPE MISMATCH is raised.
-  If the statement ends in a comma, MISSING OPERAND is raised.
-  If an error occurs, the files before the erratic value are closed.


CLS statement
CLS [x][,]
------------
Clears the screen or part of it. 
'x' is a numeric valued expression:
-  If 'x' equals 0, the whole screen is cleared.
-  If 'x' equals 1, the graphics view region is cleared.
-  If 'x' equals 2, the text view region is cleared.
If 'x' is not specified, in SCREEN 0 the text view region is cleared;
in other screens, the graphics view region is cleared.
The comma is optional and has no effect.
ERRORS:
-  If 'x' is string valued, TYPE MISMATCH is raised.
-  If 'x' is not 0,1, or 2, ILLEGAL FUNCTION CALL is raised.
-  If 'x' is not in [-32768, 32767], OVERFLOW is raised.
-  If no comma is specified but more text follows, ILLEGAL FUNCTION CALL.
-  If a comma is specified followed by more, SYNTAX ERROR.
-  If an error occurs, the screen is not cleared.


COLOR statement    (in SCREEN 0)
COLOR [foreground] [, [background] [, border] ] 
---------------
Changes the current colour attributes. 
'foreground' is a numeric expression with a value between 0 and 31 (incl.)
    This specifies the new foreground attribute. Attributes 16--31 incl. are 
    blinking versions of attributes 0--15 incl.
'background' is a numeric expression with a value between 0 and 15 (incl.)
    This specifies the new background attribute. It is taken MOD 16: Values 
    8--15 incl. produce the same colour as 0--7 incl.
'border' is a numeric expression between 0 and 15 (incl.). This is 
    optional and has no effect.
All new characters printed will take the newly set attributes. Existing
characters on the screen are not affected.
NOTES:
-   In GW-BASIC, the 'border' value in SCREEN 0 sets the attribute of the 
    screen border. This is not implemented in PC-BASIC 3.23.     
-   The syntax and effect of this command is different in different SCREEN
    modes. see below for SCREENs 1, 7, 8, and 9.
ERRORS:
-   If any of the parameters has a string value, TYPE MISMATCH is raised.
-   If any of the parameters is not in [-32768,32667], OVERFLOW is raised.
-   If 'foreground' is not in [0,31], 'background' is not in 
    [0,15] or 'border' is not in [0,15], ILLEGAL FUNCTION CALL is raised.
-   In SCREEN 2, ILLEGAL FUNCTION CALL is always raised.         
    

COLOR statement  (in SCREEN 1)
COLOR [palette_0] [, palette [, override] ]
---------------
Changes the current palette colours. 
'palette_0' is a numeric expression with a value between 0 and 255 (incl.)
    This sets the palette colour associated with attribute 0; by default, the
    background has this attribute. All pixels with this attribute will 
    change colour. The palette colour value is taken from the VGA 64-colour
    set. 'palette_0' is taken MOD 64.  
'palette' is a numeric expression with a value between 0 and 255 (incl.)
    If 'palette' is odd, the standard CGA palette (cyan, magenta, grey) is set.
    If 'palette' is even, the alternative palette (green, red, brown) is set.
    All pixels with attributes 1,2,3 will change colour to the new palette.
'override' is a numeric expression with a value between 0 and 255 (incl.)
    If 'override' is specified, palette is set as above but useing 'override'
    instead of 'palette'. 'palette' is then ignored.
ERRORS:
-   If any of the parameters has a string value, TYPE MISMATCH is raised.
-   If any of the parameters is not in [-32768,32667], OVERFLOW is raised.
-   If any of the parameters is not in [0,255], raises ILLEGAL FUNCTION CALL.


COLOR statement  (in SCREEN 7, 8, or 9)
COLOR [foreground] [, palette_0 [, dummy] ]
---------------
Changes the current colour attribute and palette colour for attribute 0. 
'foreground' is a numeric expression with a value between 1 and 15 (incl.)
    This sets the new foreground attribute. This applies only to new characters
    printed or pixels plotted.
'palette_0' is a numeric expression with a value between 0 and 15 (incl.)
    This sets the palette colour associated with attribute 0; by default, the
    background has this attribute. All pixels with this attribute will 
    change colour. 
'dummy' is a numeric expression with a value between 0 and 255 (incl.)
    The value of 'dummy' is ignored.
In SCREEN 7 and 8, the 'palette_0' colour is taken from the first 8 of 
the 16-colour EGA set. 'palette_0' is taken MOD 8.
IN SCREEN 9, the palette colour value is taken from the 64-colour VGA set.
ERRORS:
-   If any of the parameters has a string value, TYPE MISMATCH is raised.
-   If any of the parameters is not in [-32768,32667], OVERFLOW is raised.
-   If 'foreground' is not in [1,15]; 'background' is not in [0,15]; or 
    'dummy' is not in [0,255], ILLEGAL FUNCTION CALL is raised.


 
COM(port) statement
COM(port) { ON | OFF | STOP }
----------------
When using ON, enables ON COM(x) event trapping of the emulated serial port. 
When using OFF, disables trapping.
When using STOP, halts trapping until COM(x) ON is used. Events that occur 
while trapping is halted will trigger immediately when trapping is re-enabled.
'port' is a numeric expression with a value of 1 or 2. This specified which
serial port (COM1: or COM2:) is trapped.


COMMON statement
COMMON [ [var_0] [, [var_1] [, [...] ] ] ]
----------------
Specifies variables to be passed as common variables to the program called 
with CHAIN. 'var_0', 'var_1', ... are names of variables or arrays. Array names
must be followed by round or square brackets. Brackets may also be mixed (] [).
The statement may end with one or more commas. 


CONT statement
CONT [ anything ]
--------------
Resumes execution of a program that has been halted by STOP, END, <CTRL+C>, or 
 <CTRL+BREAK>.
ERRORS:
-   If no program is loaded, a program has not been run, after a program line 
    has been modified and after CLEAR, CONT raises CAN'T CONTINUE.
-   If the break occurred in a direct line, CONT raises CAN'T CONTINUE    


COS(x) function
---------------
Returns the cosine of 'x'. 'x' is a numeric-valued expression that gives the 
angle in radians. 
Unless BASIC is run with the --double option, COS(x) returns a 
single-precision value.
NOTES:
-   COS(x) usually differs from the value returned by GW-BASIC. For one-digit 
    values, the difference is only in the least significant figure, but it
    increases with the size of the angle.
ERRORS:
-   If 'x' has a string value, COS raises TYPE MISMATCH.
     

CSNG(x) function
----------------
Converts the numeric-valued expression 'x' to a single-precision value.
ERRORS:
-   If 'x' has a string value, CSNG raises TYPE MISMATCH.


CSRLIN function
---------------
Returns the screen row of the cursor on the active page. 
CSRLIN is between 1 and 25, inclusive. Note that CSRLIN has no brackets.


CVI(x) function
---------------
Converts a two-byte string to a signed integer.
'x' should be a string-valued expression that represents an integer using
little-endian two's complement encoding. Only the first two bytes are used.
ERRORS:
-   If 'x' has a number value, TYPE MISMATCH is raised.


CVS(x) function
---------------
Converts a four-byte string to a single-precision floating-point number.
'x' should be a string-valued expression that represents a single-precision
number in Microsoft Binary Format.. Only the first four bytes are used.
ERRORS:
-   If 'x' has a number value, TYPE MISMATCH is raised.


CVD(x) function
---------------
Converts an eight-byte string (internal representation) to a single.
'x' should be a string-valued expression. Only the first eight bytes are used.
ERRORS:
-   If 'x' has a number value, TYPE MISMATCH is raised.
 

DATA statement
DATA [ [const_0] [, [const_1] [, ... ]
--------------
Specifies the data that can be read by the READ statement. 'const_0', ...
are string and number literals or may be empty. String literals can be given
with or without quotation marks. If quotation marks are omitted, leading and
trailing whitespace is ignored and commas or colons will terminate the data
statement.
ERRORS:
-   If the type of the literal does not match that of the corresponding READ 
    statement, a SYNTAX ERROR occurs on the DATA statement.
    

DATE$ function
--------------
Returns the system date as a string in the format "mm-dd-yyyy".
Note that DATE$ has no brackets.


DATE$ statement
DATE$ = date
---------------
Sets the system date. 'date' is a string-valued expression that represents a 
date in one of the formats: "mm-dd-yyyy", "mm/dd/yyyy", "mm-dd-yy", "mm/dd/yy".
Of these, mm must be in [01, 12], dd must be in [01, 31]. If specified as yyyy,
the year must be in [1980, 2099]. If specified as yy, the year must be in the
range [00, 77], in which case it is interpreted as 2000--2077, or in the range
 [80, 99], which is interpreted as 1980-1999.
NOTES:
-   The system date is not actually changed; rather, PC-BASIC remembers the 
    offset from the true system date. This avoids requiring user permission
    to change the system time
-   GW-BASIC appears to accept invalid dates such as "02-31-2000". PC-BASIC
    raises ILLEGAL FUNCTION CALL for these.
ERRORS:
-   If the value of 'date' is not in the format specified above, DATE$ raises
    ILLEGAL FUNCTION CALL.
-   If 'date' yields a numeric value, TYPE MISMATCH is raised.


DEF FN statement
DEF FN name[( arg_0 [, arg_1 [, ...] )] = expression
----------------
Defines a function. 'name' must be a legal variable name. The function will 
then be called FNname (or FN name). Spaces between FN and name are optional.
'arg0', ... must be legal variable names; these are the parameters of the
function. 'expression' must be a legal PC-BASIC expression that may use the
parameters 'arg_0', 'arg_1', ... . On calling FNname(...), 'expression' is 
evaluated with the supplied parameters substituted. The result of the 
evaluation is then the value of FNname.


DEFINT statement
DEFINT letters
----------------
Sets the default type for variables starting with 'letters' to integer (%). 
This is the type that is assumed if no type character is specified. 'letters' 
are letters of the alphabet separated by commas or ranges specified with a 
dash: for example, DEFINT A,B,C-Z


DEFDBL statement
DEFDBL letters
----------------
Sets the default type for variables starting with 'letters' to double (#). 
This is the type that is assumed if no type character is specified. 'letters' 
are letters of the alphabet separated by commas or ranges specified with a 
dash: for example, DEFDBL A,B,C-Z


DEFSNG statement
DEFSNG letters
----------------
Sets the default type for variables starting with 'letters' to single (!). 
This is the type that is assumed if no type character is specified. 'letters' 
are letters of the alphabet separated by commas or ranges specified with a 
dash: for example, DEFSNG A,B,C-Z. DEFSNG A-Z is the default setting.


DEFSTR statement
DEFSTR letters
----------------
Sets the default type for variables starting with 'letters' to string ($). 
This is the type that is assumed if no type character is specified. 'letters' 
are letters of the alphabet separated by commas or ranges specified with a 
dash: for example, DEFSTR A,B,C-Z.


DEF SEG statement
DEF SEG [=address]
-----------------
Does nothing. 'address' is a numeric-valued expression in [-32768, 65535].
NOTES:
-   In GW-BASIC, sets the segment address to be used by BLOAD, BSAVE, CALL, 
    PEEK, POKE, or USR. This is not implemented in PC-BASIC.
-   If 'address' is negative, it is interpreted as its two's complement.
-   If 'address' is not specified, the segment is set to the GW-BASIC data
    segment.
ERRORS:
-   If 'address' is not in [-32768, 65535], OVERFLOW is raised.
-   If 'address' has a string value, TYPE MISMATCH is raised.


DEF USR statement
DEF USR[n] = address
-----------------
Does nothing. 'n' is a digit between 0 and 9 inclusive. 'address' is a numeric-
valued expression in [-32768, 65535].
NOTES:
-   In GW-BASIC, sets the starting address of an assembly-language function. 
    This is not implemented in PC-BASIC.
-   If 'address' is negative, it is interpreted as its two's complement.
ERRORS:
-   If 'address' is not in [-32768, 65535], OVERFLOW is raised.
-   If 'address' has a string value, TYPE MISMATCH is raised.

 
DELETE statement
DELETE [ [line_number_0] - [line_number_1] ]
DELETE [line_number_0]
----------------
Deletes lines from the program, starting with 'line_number_0' up to 
'line_number_1', which must be line numbers in the range [0, 65529] or a .
to indicate the last line edited.
Also stops program execution and returns to interactive mode.
ERRORS:
-   If a line number is greater than 65529, SYNTAX ERROR is raised.
-   If the range specified does not include any program lines stored, DELETE
    raises ILLEGAL FUNCTION CALL.
    
    
DIM statement
DIM name  { ( | [ } limit_0 [, limit_1 [, ...] ] { ) | } ]   
-------------
Dimensions (allocates memory for) arrays. 'name' is a legal variable name
specifying the array to be dimensioned. 'limit_0', ... are number-valued 
expressions that specify the greatest index allowed at that position. Mixed
brackets are allowed. The least index allowed is determined by OPTION BASE.
The DIM statement also fixes the number of indices of the array. 
An array can only de dimensioned once; to re-dimension an array, ERASE or 
 CLEAR must be executed first. 
If an array is used without a DIM statement, its maximum indices are set at 10
for each index position used. If an array's DIM statement specifies no indices,
 it is dimensioned with a single index with maximum 10.
NOTES:
-   The size of arrays is limited by the available memory. In GW-BASIC, an 
    OUT OF MEMORY is raised if the array exceeds the size of available variable
    space. This is not currently implemented in PC-BASIC.
-   The maximum number of indices is, theoretically, 255. However, in practice,
    it is limited by the 255-byte limit on the length of program lines.
ERRORS:
-   If 'name' has already been dimensioned, DUPLICATE DEFINITION is raised.
-   If an index is empty, SYNTAX ERROR is raised.
-   If an index is missing at the end, MISSING OPERAND is raised.
-   If 'limit_0', ... are not within [-32768, 32767], OVERFLOW is raised.        
-   If 'limit_0', ... are negative, ILLEGAL FUNCTION CALL is raised.


DRAW statement
DRAW gml_string
--------------
In graphics mode, draws the shape specified by 'gml_string'. 'gml_string' must
be a string-valued expression in Graphics Macro Language (GML). 
GML reference:
Movement commands have the form 
    [B][N] movement
where the default is to move and draw; the optional prefixes mean:
    B       move but do not plot
    N       return to original point after move
and 'movement' is one of:
    Un      up n steps
    Ln      left n steps
    Dn      down n steps
    Rn      right n steps
    En      up+right n steps
    Fn      down+right n steps
    Gn      down+left n steps
    Hn      up+left n steps
    M{+|-}x,{+|-|}y
            move (x,y) steps
    Mx,y    move to view region coordinates x,y  
where 'n','x','y' must be integers in [0, 9999].
Scale commands are:
    Sn      sets the step size to n/4. The default step size is 1 pixel.  
            'n' must be an integer in [1, 255]
    TAn     sets the angle to n degrees. The default angle is 0 degrees.
            'n' must be an integer in [-360, 360]
    An      sets the angle to 0 for n=0, 90 for n=1, 180 for n=2, 270 for n=3.    
            'n' must be an integer in [0, 3]
Colour commands:    
    Cn      sets the colour attribute to n. See COLOR.
    Pn,b    flood fills with attribute n and boundary attribute b. See PAINT.
Subroutine command:
    Xs      execute substring. 's' is one of the following:
            -   a string variable name followed by semicolon (;)
            -   the result of VARPTR$() on a string variable
Numeric variables 'n','x','y','b' in the commands above can be:
    -   an integer literal e.g. "100"
    -   a numeric variable name preceded by = and followed by ; e.g. "=name;"
    -   the result of VARPTR$() on a numeric variable, preceded by =.               
NOTES:
-   CLS resets the step size to 1 pixel, angle to 0 degrees and position to the
    centre of the view region.                 
ERRORS:
-   If 'gml_string' has a numeric value, TYPE MISMATCH is raised.
-   If 'gml_string' has errors in the GML, ILLEGAL FUNCTION CALL is raised.
-   If a variable in the gml_string is of incorrect type, TYPE MISMATCH.


EDIT statement
EDIT line_number
--------------
Displays the specified program line with the cursor positioned for editing.
'line_number' must be a line that exists in the program, or a period (.) to 
indicate the last line stored.
ERRORS:
-   If no line_number is specified, raises UNDEFINED LINE NUMBER.
-   If more characters are written after the line number, raises ILLEGAL 
    FUNCTION CALL.
-   If 'line_number' is not in [0,65529], raises ILLEGAL FUNCTION CALL.    
-   If the specified line number dos not exist, raises UNDEFINED LINE NUMBER.


ELSE statement
ELSE [anything]
--------------
Unless part of an IF statement on the same line, anything after ELSE is ignored
in the same way as after the apostrophe (') or :REM. No colon (:) preceding 
the ELSE statement is necessary. See IF for normal usage.


END statement
END
-------------
Closes all files, stops program execution and returns to interactive mode.
No message is printed. It is possible to resume execution at the next statement
using CONT.


ENVIRON statement
ENVIRON command_string
-----------------
Sets a shell environment parameter. 'command_string' must be a string-valued
expression of one of the following forms:
    "PARAMETER=VALUE"   to set PARAMETER to VALUE
    "PARAMETER="        to unset PARAMETER
ERRORS:
-   If 'command_string' has a numeric value, TYPE MISMATCH is raised.
-   If 'command_string' is not of the required form, ILLEGAL FUNCTION CALL is 
    raised.


ENVIRON$ function    
value = ENVIRON$(x)
--------------------
Returns an environment parameter. 'x' is an expression.
If 'x' has a string value, returns the value for the parameter 'x' or the empty
string if no parameter with the name 'x' is set.
If 'x' has a numeric value, it must be in [1, 255]. Returns the 'x'th entry in 
the environment table.
ERRORS:
-   If 'x' is the empty string, raises ILLEGAL FUNCTION CALL.
-   If 'x' is a number not in [1,255], raises ILLEGAL FUNCTION CALL.
-   If 'x' is a number not in [-32768,32767], raises OVERFLOW.


EOF function
is_at_end = EOF(file_num) 
------------
Returns -1 if file with number 'file_num' has reached end-of-file; 0 otherwise.
The file must be open in INPUT or RANDOM mode. EOF(0) returns 0.
NOTES:
-   If 'file_num' is open to KYBD:, performs a blocking read and returns -1 if 
    <CTRL+Z> is entered, 0 otherwise. The character entered is then echoed to 
    the console.
ERRORS:
-   If 'file_num' is a number not in [0,255], raises ILLEGAL FUNCTION CALL.
-   If 'file_num' is a number not in [-32768,32767], raises OVERFLOW.
-   If 'file_num' is not 0 or the number of an open file, raises 
    BAD FILE NUMBER.
-   If file with number 'file_num' is in OUTPUT or APPEND mode, raises 
    BAD FILE MODE.


ERASE statement
ERASE array_0 [, array_1 [, ...] ] 
---------------
Disallocates arrays to allow them to be re-dimensioned. The data stored in the
array is lost. 'array_0', ... are names of existing arrays. The names must be
specified without brackets.
NOTES:
-   If an error occurs, the arrays named before the error occurred are erased.
ERRORS:
-   If no array names are given, raises SYNTAX ERROR.
-   If 'array_0', ... does not exist, raises ILLEGAL FUNCTION CALL.


ERDEV function
zero = ERDEV
--------------
Returns 0. No brackets.
NOTES:
-   In GW-BASIC, returns the value of a device error. This is not implemented.


ERDEV$ function
empty = ERDEV$
---------------
Returns the empty string. No brackets.
NOTES:
-   In GW-BASIC, the device name of a device error. This is not implemented.


ERL function
error_line = ERL
------------
Returns the line number where the last error was raised. If the error was 
raised in interactive mode, returns 65535. If no error has been raised, 
returns 0. No brackets.


ERR function
error_code = ERR
------------
Returns the number of the last error. If no error has been raised, returns 0.
No brackets.
NOTES:
-   If the last error was a SYNTAX ERROR in interactive mode, returns 0.


ERROR statement
ERROR error_number
---------------
Raises the error with number 'error_number'. 'error_number' is an expression 
with a numeric value. 
ERRORS:
-   If 'error_number' is a string value, raises TYPE MISMATCH.
-   If 'error_number' is not in  [-32768, 32767], raises OVERFLOW.
-   If 'error_number' is not in [1,255], raises ILLEGAL FUNCTION CALL.


EXP(x) function
---------------
Returns the exponential of 'x', i.e. e to the power 'x'. 'x' must be a number-
valued expression. 
NOTES:
-   Unless BASIC is run with the --double option, EXP(x) returns a single-
    precision value.
-   Exp sometimes differs in the least significant digit from GW-BASIC. For 
    large values of 'x', the difference may be 3 digits.
ERRORS:
-   If 'x' has a string value, raises TYPE MISMATCH.
-   If 'x' is larger than the natural logarithm of the maximum single-precision
    value, raises OVERFLOW.


EXTERR function
zero = EXTERR(x)
---------------
Returns 0. 'x' must be a number-valued expression in [0, 3].
NOTES:
-   In GW-BASIC, EXTERR returns extended error information from MS-DOS. 
    This is not implemented.
ERRORS:
-   If 'x' is a string value, raises TYPE MISMATCH.
-   If 'x' is not in [-32768, 32767], raises OVERFLOW.
-   If 'x' is not in [0,3], raises ILLEGAL FUNCTION CALL.


FIELD statement
FIELD [#] file_number [, width_0 AS name_0 [, width_1 AS name_1 [, ...] ] ]
---------------
Maps variables to the random-access record buffer. The record buffer is a 
region of memory of length defined by the OPEN statement; the default record
length is 128 bytes. The FIELD statement associates a portion of this region to
one or more fixed-length string variables, so that the value of these strings
is whatever happens to be in the record buffer at that location. 
'file_number' is a numeric expression that yields the number of an open random-
access file. The # is optional and has no effect. 'width_0' is a numeric 
expression giving the length of the first string variable; 'name_0' is a valid 
string variable name, and so on for further variables. A FIELD statement 
without any variables specified has no effect.
A FIELD statement on the same file will specify an alternative mapping of the 
same file buffer; all mappings will be in effect simultaneously.
A subsequent assignment or LET or MID$ statement on 'name_0', ... will dis-
associate the string variable from the field buffer. Use LSET or RSET to change
values in the field buffer. Use GET to read values from the file into the field
buffer, changing the variables. Use PUT to write the field buffer to the file.
ERRORS:
-   If 'file_number' is not in [0,255], raises ILLEGAL FUNCTION CALL.
-   If 'file_number' is not the number of an open file, raises
    BAD FILE NUMBER.
-   If 'file_number' is open under a mode other than RANDOM, raises
    BAD FILE MODE.
-   If the statement ends in a comma, raises MISSING OPERAND.
-   If no file number is specified, raises MISSING OPERAND.
-   If the lengths in a FIELD statement add up to a number larger than the 
    record length of the field buffer, FIELD OVERFLOW is raised.
-   If 'name_0', ... specify a non-string variable, raises TYPE MISMATCH.


FILES statement
FILES path_and_filter
---------------
Displays the files fitting the specified filter in the specified directory. If
'path_and_filter' is not specified, displays all files in the current working 
directory. If specified, 'path_and_filter' is a string-valued expression that
consists of two optional parts: the first part is the path to the directory; 
the second part is the filename filter. The file part is a path list separated
by backslashes (\) as in MS-DOS. The filename filter consists of file name
parts and the wildcards ?, matching any character but not the \ or .; and the 
* matching any series of characters excluding . or \. If specified, a filter
will only match MS-DOS style 8.3 all-uppercase filenames. If all files in a 
specified directory are required, end the directory name with a backslash \.
The path directories, however, can be case sentitive and longer according to
the host OS's standards.
ERRORS:
-   If 'path_and_filter' has a numeric value, TYPE MISMATCH is raised.
-   If 'path_and_filter' is the empty string, BAD FILE NAME is raised.
-   If the specified filter does not match any files, FILE NOT FOUND is raised.


FIX function
whole = FIX(number)
------------
Returns 'number' truncated towards zero.    
'number' must be a numeric-valued expression.
NOTES:
-   While FIX truncates towards zero (i.e. removes the fractional part), INT
    truncates towards negative infinity. For negative 'x', FIX(x)-INT(x)==1.
ERRORS:
-   If 'number' is a string-valued expression, TYPE MISMATCH is raised.


FN function
result = FN name (arg_0 [, arg_1 [, ...] ])
-----------
Evaluates a user_defined function. 'name' must be a legal variable name. 
Spaces between FN and name are optional.
'arg0', ... must be legal variable names; these are the parameters of the
function. 
ERRORS:
-   If no function named 'name' is defined, raises 
    UNDEFINED USER FUNCTION.

 
FOR statement
FOR loop_var = start TO stop [STEP step]
----------------------------------------
Initiates a FOR--NEXT loop. 'loop_var' is a valid numeric variable name. 
'start', 'stop' and 'step' are number-valued expressions. 
Initially, 'loop_var' is set to 'start' Then, the statements between the FOR 
statement and the NEXT statement are executed and 'loop_var' is incremented by
'step' (if 'step' is not specified, by 1). This is repeated until 'loop_var' 
has become greater than or equal to 'stop'. Execution then continues at the 
statement following NEXT.
ERRORS:
-   If no NEXT statement is found to match the FOR statement, FOR WITHOUT NEXT
    is raised at the FOR statement.
-   If 'loop_var' is a string name or 'start','stop','end' are string-valued,
    TYPE MISMATCH is raised.
        

FRE function
free_mem = FRE(x)
------------
Returns the available model memory. 'x' is an expression. If 'x' is number-
valued, it is ignored. If 'x' is string valued, garbage collection is performed
before returning available model memory.


GET statement   (random-access files)
GET [#] file_number [, record_number]
-------------
Read a record from the random-access file 'file_number' at position
'record_number'. 'file_number' is a numeric expression that yields the number 
of an open random-access file. The # is optional and has no effect. 
'record_number' is a numeric expression that gives a number between 1 and 
33554432 (2^25), inclusive, and is interpreted as the record number. 
The record can be accessed through the FIELD variables, or through INPUT$,
 INPUT or LINE INPUT.
NOTES:
-   If the record number is beyond the end of the file, the file buffer is 
    filled with null bytes.
ERRORS:
-   If 'record_number' is not in [1, 33554432], raises BAD RECORD NUMBER.
-   If 'file_number' is not in [0,255], raises ILLEGAL FUNCTION CALL.
-   If 'file_number' is not the number of an open file, raises
    BAD FILE NUMBER.
-   If 'file_number' is open under a mode other than RANDOM, raises
    BAD FILE MODE.
-   If 'file_number' is not specified, raises MISSING OPERAND.
    

GET statement   (communications)
GET [#] com_file_number, [, number_bytes]
-------------
Read 'number_bytes' bytes from the communications buffer opened under file 
number 'com_file_number'. 'number_bytes' is a numeric expression between 1
and the COM buffer length, inclusive.
The record can be accessed through the FIELD variables but not through INPUT,
 INPUT$ and LINE INPUT.
NOTES:
-   If 'bytes' is 32768 or greater, GW-BASIC hangs (tries to read that many 
    bytes?). This is not implemented in PC-BASIC 3.23.
-   In GW-BASIC, DEVICE I/O ERROR is raised for overrun error, framing error,
    and break interrupt. DEVICE FAULT is raised if DSR is lost during I/O. A
    PARITY ERROR is raised if parity is enabled and incorrect parity is 
    encountered. This is according to the manual; it is untested.
ERRORS:
-   If 'bytes' is less than 1, raises BAD RECORD NUMBER
-   If 'bytes' is less than 32768 and greater than the COM buffer length,
    raises ILLEGAL FUNCTION CALL
-   If 'com_file_number' is not specified, raises MISSING OPERAND.
-   If 'com_file_number' is not in [0,255], raises ILLEGAL FUNCTION CALL.
-   If 'com_file_number' is not the number of an open file, raises
    BAD FILE NUMBER.
-   If the serial input buffer is full, i.e. LOF(com_file_number) == 0, and 
    LOC(com_file_number)==255, raises COMMUNICATION BUFFER OVERFLOW
-   If the carrier drops during GET, hangs until a break key is entered.
        
    
GET statement   (graphics)
GET (x0,y0)-(x1,y1), array_name
-------------
Stores a rectangular area of the graphics screen in an array. 'array_name' must
be the name of a numeric array dimensioned with enough space to store the area. 
The area stored is a rectangle parallel to the screen edges, bounded by the 
top-left and bottom-right coordinates 'x0','y0' and 'x1','y1'. The area is such
that these points are inside it. 'x0', ... 'y1' are number-valued expressions. 
The image stored in the array can then be put on the screen using PUT. For the 
purposes of GET, any array is considered a string of bytes. The byte size of an
array can be calculated as number_elements * byte_size with bytes_size equal to
2 for integers (%), 4 for single (!) and 8 for double (#). Array byte size for
string is 3, but string arrays are not allowed in GET. For calculating the 
number of elements, keep in mind that OPTION BASE 0 is the default; in which 
case an array with maximum index 10 has 11 elements. This works trough in
multidimensional arrays. 
Format in array:
    0,1 number of x pixels, unsigned int. In SCREEN 1, this value is doubled.
    2,3 number of y pixels, unsigned int.
    4...pixel data (many bytes)
Pixel data format:
    Data is arranged in 2-byte words. The first 16-bit word holds the bit 0 of 
    the first 16 pixels on the top row. The second word holds the second bit,
    etc. Data is word-aligned at the end of each row. Thus, in a screen mode 
    with 4 bits per pixel, the first row takes at least 8 bytes (4 words), even
    if it consists of only one pixel. The number of bits per pixel depends on 
    the SCREEN mode.
ERRORS:
-   If the array does not exist, raises ILLEGAL FUNCTION CALL.
-   If 'array_name' refers to a string array, raises TYPE MISMATCH.
-   If the area is too large for the array, raises ILLEGAL FUNCTION CALL.  
-   If 'x0', ... 'y1' are string expressions, raises TYPE MISMATCH.
-   If 'x0', ... 'y1' are not in [-32768, 32767], raises OVERFLOW.
-   If 'x0', ... 'y1' are outside the current VIEW or WINDOW, raises
    ILLEGAL FUNCTION CALL
    

GOSUB statement
GOSUB line_number [ anything ]
---------------
Jumps to a subroutine at 'line_number'. The next RETURN satement jumps back to
the statement after GOSUB. Anything after 'line_number' until the end of the 
statement is ignored. If executed in interactive mode, GOSUB enters runmode and
the following RETURN returns execution to the direct line.
'line_number' must be an existing line number literal. Further characters on 
the line are ignored until end of statement.
NOTES:
-   If no RETURN is encountered, no problem.
ERRORS:
-   If 'line_number' does not exist, raises UNDEFINED LINE NUMBER.
-   If 'line_number' is greater than 65529, only the first 4 characters are 
    read (e.g. 6553)


GOTO statement
GOTO line_number [anything]
--------------
Jumps to 'line_number'.  Anything after 'line_number' until the end of the 
statement is ignored. If executed in interactive mode, GOTO enters runmode and
the following RETURN returns execution to the direct line.
'line_number' must be an existing line number literal. Further characters on 
the line are ignored until end of statement.
ERRORS:
-   If 'line_number' does not exist, raises UNDEFINED LINE NUMBER.
-   If 'line_number' is greater than 65529, only the first 4 characters are 
    read (e.g. 6553)
    

HEX$ function
hex_repr = HEX(x)
----------------
Returns a string with the hexadecimal representation of 'x'. 'x' must be a 
number-valued expression between -32768 and 65535, inclusive. Values for 
negative 'x' are shown as two's-complement. 
ERRORS:
-   If 'x' is not in [-32768, 65535], OVERFLOW is raised.
-   If 'x' has a string value, TYPE MISMATCH is raised.


IF statement
IF truth_value [,] { THEN | GOTO } [ statements_1 | line_number_1 [anything] ]
    [ ELSE [ statements_0 | line_number_0 [anything] ] ]
------------
If 'truth_value' is non-zero, executes statements_1 / jumps to line_number_1. 
If it is zero, executes statements_0 or jumps to line_number_1. 'truth_value' 
is a number-valued expression. The comma is optional and ignored. 
'line_number_0' and 'line_number_1' are valid existing line numbers. 
Statements 'statements_0' and 'statements_1' can be compound statements with
one or more colons (:) separating single statements. The compound statements 
can contain nested IF..THEN..ELSE statements. ELSE clauses are optional; they
are bound to the innermost free IF statement if nested. Additional ELSE 
clauses that have no matching IF are ignored. All clauses must be on the same 
program line.
NOTES:
-   THEN and GOTO are interchangeable; which one is chosen is independent
    of whether a statement or a line number is given. GOTO PRINT 1 is fine.
-   As in GOTO, anything after the line number is ignored.
-   If 'truth_value' has a string value, raises TYPE MISMATCH.
    
    
INKEY$ function 
---------------
Returns one keypress from the keyboard buffer. If the keyboard buffer is 
empty, returns the empty string. Otherwise, the return value is either a one
character string or a two-character string of which the first is CHR$(0) and
the second a keyboard scancode.
The hex values for keyboard scancodes returned by INKEY$ are:
    <UP>            48
    <DOWN>          50
    <RIGHT>         4D
    <LEFT>          4B
    <INSERT>        52
    <DELETE>        53
    <HOME>          47
    <END>           4F
    <PAGEUP>        49
    <PAGEDOWN>      51
    <F1>            3B
    <F2>            3C
    <F3>            3D
    <F4>            3E
    <F5>            3F
    <F6>            40
    <F7>            41
    <F8>            42
    <F9>            43
    <F10>           44
    <PRINT>         37
    <CTRL+RIGHT>    74
    <CTRL+LEFT>     73
    <CTRL+HOME>     77
    <CTRL+END>      75
    <CTRL+PAGEUP>   84
    <CTRL+PAGEDOWN> 76
    <CTRL+2>        03
    <CTRL+9>        84
    <CTRL+F2>       5F
    <CTRL+F3>       60



INP function
code = INP(x)
------------
If 'x'==&H60, returns the keyboard scancode for the last key pressed
'x' is a numeric expression with a value between 0 and 65535, inclusive.
Returns zero otherwise. 
The scancodes returned by INP(&H60) are listed below. If the key is currently
down, the scancode is returned; if it has been released, the scancode is 
incremented by 128.
Scancodes returned by INP(&H60):
    <ESC>       01
    <1>         02
    <2>         03
    <3>         04
    <4>         05
    <5>         06
    <6>         07
    <7>         08
    <8>         09
    <9>         0A
    <0>         0B
    <->         0C
    <=>         0D
    <BACKSPACE> 0E
    <TAB>       0F
    <q>         10
    <w>         11
    <e>         12
    <r>         13
    <t>         14
    <y>         15
    <u>         16
    <i>         17
    <o>         18
    <p>         19
    <[>         1A
    <]>         1B
    <ENTER>     1C
    <CTRL>      1D
    <a>         1E
    <s>         1F
    <d>         20
    <f>         21
    <g>         22
    <h>         23
    <j>         24
    <k>         25
    <l>         26
    <;>         27
    <'>         28
    <`>         29
    <LSHIFT>    2A
    <#>         2B
    <z>         2C
    <x>         2D
    <c>         2E
    <v>         2F
    <b>         30
    <n>         31
    <m>         32
    <,>         33
    <.>         34
    </>         35
    <RSHIFT>    36
    <PRTSC>     37
    <SYSRQ>     37
    <ALT>       38
    <SPACE>     39
    <CAPSLOCK>  3A
    <F1>        3B
    <F2>        3C
    <F3>        3D
    <F4>        3E
    <F5>        3F
    <F6>        40
    <F7>        41
    <F8>        42
    <F9>        43
    <F10>       44
    <NUMLOCK>   45
    <SCROLLOCK> 46
    <HOME>      47
    <UP>        48
    <PGUP>      49
    <KEYPAD ->  4A
    <LEFT>      4B
    <KEYPAD 5>  4C
    <RIGHT>     4D
    <KEYPAD +>  4E
    <END>       4F
    <DOWN>      50
    <PGDN>      51
    <INS>       52
    <DEL>       53
NOTES:
-   In GW-BASIC, returns a byte read from machine port 'x'. This is not 
    implemented in PC_BASIC 3.23, except for the common use case of INP(&H60).
ERRORS:
-   If 'address' is not in [-32768, 65535], OVERFLOW is raised.
-   If 'address' has a string value, TYPE MISMATCH is raised.
        

INPUT statement (screen)
INPUT [;] [ prompt {;|,} ] var_0 [, var_1 [, ... ] ]
---------------
Prints 'prompt' to the screen and waits for the user to input values for var_0,
 ... . 'prompt' is a string literal. 'var_0', ... are variable names or 
fully indexed array elements.  The semicolon before the prompt, if present, 
stops a newline from being printed after the values have been entered.
If the prompt is followed by a semicolon, it is printed with a trailing ?. If 
the prompt is followed by a comma, no question mark is added. 
NOTES:
-   Values entered must be separated by commas. Leading and trailing whitespace
    is discarded.
-   String values can be entered with or without double quotes ("). 
-   If a string with a comma, leading or trailing whitespace is needed, 
    quotes are the only way to enter it. 
-   Between a closing quote and the comma at the end of the entry, only white-
    space is allowed.    
-   If quotes are needed in the string itself, the first character must be 
    neither a quote nor whitespace. It is not possible to enter a string that
    starts with a quote through INPUT.
-   If a given 'var_n' is a numeric variable, the value entered must be a valid
    number literal.
-   Characters beyond the 255th character of the screen line are discarded.    
ERRORS:
-   If the value entered for a numeric variable is not a valid numeric literal,
    or the number of values entered does not match the number of variables in 
    the statement,
    ?REDO FROM START is printed and all values must be entered again. 
-   A SYNTAX ERROR that is caused after the prompt is printed is only raised
    after the value shave been entered. No values are stored.
    

INPUT# statement (text files, devices, or random-access files)
INPUT # file_num, var_0 [, var_1 [, ...] ]
----------------
Reads string or numeric variables from a text file, device, or the FIELD buffer
of a random access file. 'file_num' must be the number of a file open in 
INPUT mode or a device or random-access file open in RANDOM mode. 'var_0', ... 
are variable names or fully indexed array elements.   
NOTES:
-   The # is mandatory. There may or may not be whitepace between INPUT and #.        
-   String values can be entered with or without double quotes ("). 
-   Numeric values are terminated by space, LF, CR, comma.
-   Unquoted strings are terminated by LF, CR, comma.
-   Quoted strings are terminated by the closing quote.
-   Any entry is terminated by end-of-file &h1a or its 255th character.
-   Leading and trailing whitespace is discarded.
-   If the entry cannot be converted to the requested type, a zero value is
    returned.
-   If 'file_num' is open to KYBD:, INPUT# reads from the keyboard until a
    return or comma is encountered (as in a file). Arrow keys and delete are
    passed as their control characters (NOT scancodes!) preceded by CHR$(&HFF).
ERRORS:
-   If input is requested after the end of a text file has been reached or an
    EOF char has been encountered, raises INPUT PAST END.
-   If the last character of the field buffer is read, raises FIELD OVERFLOW.     
-   If 'file_num' is not an open file, raises BAD FILE NUMBER.
-   If 'file_num' is less than zero, raises ILLEGAL FUNCTION CALL.
-   If 'file_num' is greater than 32767, raises OVERFLOW.
-   If 'file_num' is not open for INPUT or RANDOM, raises BAD FILE MODE.
-   If 'file_num' is a string, raises TYPE MISMATCH.
    

INPUT$ function
chars = INPUT$(num_chars [, [#] file_num])
---------------
Returns a string of 'num_chars' characters from the keyboard or a file. 
'num_chars' must be a number-valued expression between 1 and 255, inclusive.
If 'file_num' is provided, reads the string from a text file. 'file_num' must
be a number valued expression that returns the number of a text file opened in
 INPUT mode. The hash is optional and has no effect.
NOTES:
-   This is a blocking read. It will wait for characters if there are none 
    in the buffer.
-   All control characters except <CTRL+BREAK>, <CTRL+SCROLLOCK> and <PAUSE> 
    are passed to the string by INPUT$. <CTRL+BREAK> and <CTRL+SCROLLOCK> break
    execution whereas <PAUSE> halts until another key is pressed (and not read).
-   When reading from the keyboard directly or through KYBD:, arrow keys, <DEL>,
    <HOME>, <END>, <PGUP>, <PGDN> are passed as NUL characters. Function keys
    are ignored if they are event-trapped, otherwise keyword replacement is
    active as normal.    
ERRORS:
-   If 'num_chars' is not in [-32768, 32767], raises OVERFLOW.
-   If 'num_chars' is not in [1, 255], raises ILLEGAL FUNCTION CALL.
-   If 'file_num' is not an open file, raises BAD FILE NUMBER.
-   If 'file_num' is less than zero, raises ILLEGAL FUNCTION CALL.
-   If 'file_num' is greater than 32767, raises OVERFLOW.
-   If 'file_num' is not open for INPUT, raises BAD FILE MODE.
-   If 'num_chars' or 'file_num' are strings, raises TYPE MISMATCH.
    
    
INSTR function
position = INSTR([start,] parent, child)
--------------
Returns the location of the first occurrence of the substring 'child' in 
'parent'. 'parent' and 'child' must be string-valued expressions. If 'start' is
provided, it must be a number-valued expression between 1 and 255, specifying
the starting position from where to look; if not specified, the search starts 
at character 1.
NOTES:
-   If 'child' is not a substring of 'parent' occurring at or before 'start', 
    INSTR returns 0.
ERRORS:
-   If 'start' is not in [-32768, 32768], raises OVERFLOW.
-   If 'start' is not in [1, 255], raises ILLEGAL FUNCTION CALL.
-   If 'start' has a string value or 'parent' or 'child' have number values, 
    raises TYPE MISMATCH.


INT function
whole = INT(number)
------------
Returns 'number' truncated towards negative infinity.    
'number' must be a numeric-valued expression.
NOTES:
-   While FIX truncates towards zero (i.e. removes the fractional part), INT
    truncates towards negative infinity. For negative 'x', FIX(x)-INT(x)==1.
ERRORS:
-   If 'number' is a string-valued expression, TYPE MISMATCH is raised.
 

IOCTL statement
IOCTL [#] file_num, control_string
---------------
Raises ILLEGAL FUNCTION CALL.
NOTES:
-   In GW-BASIC, IOCTL send a control string to a device. This is not 
    implemented in PC-BASIC 3.23.
ERRORS:
-   If 'file_num' is not an open file, raises BAD FILE NUMBER.
-   If 'file_num' is not in [-32768, 32767], raises OVERFLOW.
-   If 'file_num' has a string value, raises TYPE MISMATCH.
-   Otherwise, raises ILLEGAL FUNCTION CALL


IOCTL$ function
result = IOCTL$([#] file_num)
---------------
Raises ILLEGAL FUNCTION CALL.
NOTES:
-   In GW-BASIC, IOCTL$ reads the reply to IOCTL from a device. This is not 
    implemented in PC-BASIC 3.23.
ERRORS:
-   If 'file_num' is not an open file, raises BAD FILE NUMBER.
-   If 'file_num' is not in [-32768, 32767], raises OVERFLOW.
-   If 'file_num' has a string value, raises TYPE MISMATCH.
-   Otherwise, raises ILLEGAL FUNCTION CALL

    
KEY statement (string macro control)
KEY { ON | OFF | LIST }
-------------
Turns string macros ON or OFF; if LIST is specified, produces a list of
the 10 function keys with the string macros defined for those keys. Special 
characters are represented by their symbol equivalent in the loaded codepage;
some characters get a special representaation. E.g. chr$(13) is represented 
as a back arrow. 


KEY statement (string macro definition)
KEY key_id, string_value
-------------
Defines the string macro for key 'key_id'. 'key_id' must be a number-valued 
expression in the range 1--10, inclusive. 'string_value' must be a string-
valued expression. Only the first 15 caracters of 'string_value' are stored.
NOES:
-   IF 'key_id' is not in the range [1, 10], the statement is interpreted as an
    event trapping key definition (see below).
ERRORS:
-   If 'key_id' is not in [-32768, 32767], raises OVERFLOW.
-   If 'key_id' is not in [1, 255], raises ILLEGAL FUNCTION CALL.
-   If 'key_id' has a string value, raises TYPE MISMATCH.


KEY statement (event trapping control)
KEY ( key_id ) { ON | OFF | STOP } 
-------------
Controls event trapping of the key with identifier 'key_id'. If ON is specified
event trapping is switched on; if OFF, off. STOP suspends event trapping until 
another KEY() ON is executed. Up to one event can be triggered during 
suspension, provided that event handling was switched on prior to suspension. 
he event triggered during suspension is handled immediately after the next ..ON
statement.
'key_id' must be a number-valued expression in the range 1--20, inclusive. 
Keys 1--10 are F1--F10. Keys 11--14 are:
    11  <UP>
    12  <LEFT>
    13  <RIGHT>
    14  <DOWN>
Keys 15 to 20 are defined using the event trapping KEY definition statement
as described below.    
ERRORS:
-   If 'key_id' is not in [-32768, 32767], raises OVERFLOW.
-   If 'key_id' is not in [0, 20], raises ILLEGAL FUNCTION CALL.
-   If 'key_id' has a string value, raises TYPE MISMATCH.
 

KEY statement (event trapping key definition)
KEY key_id, two_char_string
-------------
Defines the key to trap for 'key_id'. 'key_id' must be a number-valued 
expression in the range 15--20, inclusive. 'string_value' must be a string-
valued expression of length 2. The first character is interpreted as a modifier
while the second character is interpreted as a scan code. See INP for scan
codes. Modifiers are:
    &h80    Extended
    &h40    <CAPSLOCK>
    &h20    <NUMLOCK>
    &h08    <ALT>
    &h04    <CTRL>
    &h02    <SHIFT> (either side)
    &h01    <SHIFT> (either side)
NOTES:
-   If 'key_id' is not in [15,20], no error is raised, but strange things can 
    happen in GW-BASIC: screen anomalies and crashes suggestive of unintended
    memory access. This is not implemented in PC-BASIC: such values are 
    ignored.
-   If 'key_id' is in 1--10, the statement is interpreted as a string macro
    definition, see above.
ERRORS:
-   If 'key_id' is not in [-32768, 32767], raises OVERFLOW.
-   If 'key_id' is not in [1, 255], raises ILLEGAL FUNCTION CALL.
-   If 'key_id' has a string value, raises TYPE MISMATCH.
-   If 'two_char_string' is longer than two, raises ILLEGAL FUNCTION CALL. 
-   If 'two_char_string' has a numeric value, raises TYPE MISMATCH.


KILL statement
KILL file_path
--------------
Deletes a file. 'file_path' must be a string-valued expression that specifies a
valid path to an existing file with MS-DOS path separators (\). The extension 
must be specified: no default extensions are assumed. KILL will first attempt 
to delete a file with the name exactly as provided; this is case-sensitive if
the file system is. If such a file does not exist, KILL attempts to delete the
UPPERCASE 8.3 variant of the file name.  
ERRORS:
-   If the file 'file_path' is open, raises FILE ALREADY OPEN
-   If the file or path 'file_path' does not exist, raises FILE NOT FOUND
-   If the user has no write permission, raises PERMISSION DENIED 
-   If a syntax error occurs after the closing quote, the file is removed 
    anyway.
-   If 'file_path' has a number value, raises TYPE MISMATCH.


LCOPY statement
LCOPY [num]
---------------
Does nothing. 'num' is a number-valued expression between 0 and 255, inclusive.
NOTES:
-   This statement does nothing in GW-BASIC. Presumably, it is left over from a
    statement in older versions of MS Basic that would copy the screen to the 
    printer.
ERRORS:
-   If 'num' is not in [-32768, 32767], raises OVERFLOW.
-   If 'num' is not in [0, 255], raises ILLEGAL FUNCTION CALL.
-   If 'num' has a string value, raises TYPE MISMATCH. 


LEFT$ function
child = LEFT$(parent, num_chars)
--------------
Returns the leftmost 'num_chars' characters of 'parent'. 'parent' must be a 
string-valued expression. 'num_chars' must be a numeric expression between 0 
and 255, inclusive. If 'num_chars' is zero or 'parent' is empty, LEFT$ returns
an empty string "". If 'num_chars' is greater than the length of 'parent', 
returns 'parent'.
ERRORS:
-   If 'num_chars' is not in [-32768, 32767], raises OVERFLOW.
-   If 'num_chars' is not in [0, 255], raises ILLEGAL FUNCTION CALL.
-   If 'num_chars' has a string value, raises TYPE MISMATCH.


LEN function
length = LEN(string)
--------------
Returns the number of characters in 'string'. 'string' is a string-valued
expression.
ERRORS:
-   If 'string' has a number value, raises TYPE MISMATCH.


LET statement
[LET] name = expression
-------------
Assigns the value of 'expression' to the variable or array element 'name'. 
'name' must be a valid variable name that may or may not already exist. The
type of 'expression' must match that of 'name': that is, all numeric types can 
be assigned to each other but strings can only be assigned to strings.
ERRORS:
-   If 'name' and 'expression' are not of matching types, raises TYPE MISMATCH.


LINE statement
LINE [(x0, y0)] - (x1, y1) [, [attr] [, [B [F]] [, pattern]]]
--------------
Draws a line or a box in graphics mode. If B is not specified, a line is drawn
from ('x0', 'y0') to ('x1', 'y1'), endpoints inclusive. If B is specified, a 
rectangle is drawn with sides parallel to the screen and two opposing corners 
specified by ('x0', 'y0') and ('x1', 'y1'). If the starting point is not given, 
the current graphics position is used as a staring point. LINE moves the 
current graphics position to ('x1', 'y1'). 
If F is specified with B, the rectangle is filled with the specified attribute. 
F and B may be separated by zero or more spaces. 
'attr' must be a number-valued expression between 0 and 255, inclusive, which 
    specifies the colour attribute of the line. If it is not given, the current 
    attribute is used. 
If 'pattern' is specified, it must be a number-valued expression between -32768 
    and 32767, inclusive. This is interpreted as a 16-bit binary pattern mask 
    applied to consecutive pixels in the line: a 1 bit indicates a pixel 
    plotted; a 0 bit indicates a pixel left untouched. The pattern starts at 
    the most significant bit, which is applied to the topmost endpoint. If a 
    box is drawn, the pattern is applied in the following counter-intuitive 
    sequence: (x1, y1)-(x0, y1), (x1, y0)-(x0, y0), then (x1, y0)-(x1, y1), 
    (x0, y0)-(x0, y1) if y0<y1 and y0,y1 reversed if y1<y0. When drawing a 
    filled box, LINE ignores the pattern.
NOTES:
-   If a coordinate is outside the screen boundary, it is replaced with -1 (if
    less than 0) or the screen dimension (if larger than the screen dimension).
ERRORS:
-   If LINE ends in a comma and it is the first or third, MISSING OPERAND is
    raised. If it is the second, SYNTAX ERROR is raised.
-   If any of the coordinates is not in [-32768, 32767], OVERFLOW is raised.
    

LINE INPUT statement
LINE INPUT [;] [prompt_literal {;|,}] string_name
--------------------
Displays the prompt given in 'prompt_literal' and reads user input from the 
keyboard, storing it into the variable 'string_name'. All input is read until
<ENTER> is pressed; the first 255 characters are stored. If the ; is given 
right after LINE INPUT, the <ENTER> ending user input is not echoed to the 
screen. 
'prompt_literal' must be a string literal. It makes no difference whether it is
followed by a comma or a semicolon.
'string_name' must be a valid string variable name or array element.
NOTES:
-   If user input is interrupted by <CTRL+BREAK>, CONT will re-execute the LINE 
    INPUT statement.
-   Unlike INPUT, LINE INPUT does not end the prompt with a question mark (?).


LINE INPUT# statement
LINE INPUT # file_num, string_name
---------------------
Reads string or numeric variables from a text file, device, or the FIELD buffer
of a random access file. All input is read until <ENTER> is pressed; the first 
255 characters are stored. 'file_num' must be the number of a file open in 
INPUT mode or a device or random-access file open in RANDOM mode. 
'string_name' must be a valid string variable name or array element.
NOTES:
-   The # is mandatory. There may or may not be whitepace between INPUT and #.        
-   Input is only terminated by a <CR>.
-   If 'file_num' is open to KYBD:, INPUT# reads from the keyboard until a
    return or comma is encountered (as in a file). Arrow keys and delete are
    passed as their control characters (NOT scancodes!) preceded by CHR$(&HFF).
ERRORS:
-   If input is requested after the end of a text file has been reached or an
    EOF char has been encountered, raises INPUT PAST END.
-   If the last character of the field buffer is read, raises FIELD OVERFLOW.     
-   If 'file_num' is not an open file, raises BAD FILE NUMBER.
-   If 'file_num' is less than zero, raises ILLEGAL FUNCTION CALL.
-   If 'file_num' is not in [-32768,32767], raises OVERFLOW.
-   If 'file_num' is not open for INPUT or RANDOM, raises BAD FILE MODE.
-   If 'file_num' is a string, raises TYPE MISMATCH.


LIST statement
LIST [ [line_number_0] - [line_number_1] ] [, file_name]
LIST [line_number_0] [, file_name]
--------------
Prints the program to the screen, starting with 'line_number_0' up to and 
including 'line_number_1', which must be line numbers in the range [0, 65529]
or a . to indicate the last line edited. The line numbers do not need to exist;
they specify a range. If the range is empty, nothing is printed.
'file_name' is a valid file name. This file will be created; if it already 
exists, it will be overwritten.
Also stops program execution and returns to interactive mode.
ERRORS:
-   If a line number is greater than 65529, SYNTAX ERROR is raised.
-   If 'file_name' has a numeric value, TYPE MISMATCH is raised.
-   If 'file_name' ends in a colon but is not a device name or drive letter,
    BAD FILE NUMBER is raised.
    

LLIST statement
LLIST [ [line_number_0] - [line_number_1] ] 
LLIST [line_number_0] 
---------------
Prints the program to LPT1:, starting with 'line_number_0' up to and 
including 'line_number_1', which must be line numbers in the range [0, 65529]
or a . to indicate the last line edited. The line numbers do not need to exist;
they specify a range. If the range is empty, nothing is printed.
Also stops program execution and returns to interactive mode.
ERRORS:
-   If a line number is greater than 65529, SYNTAX ERROR is raised.


LOAD statement
LOAD file_name [, R]
--------------
Loads the program stored in file 'file_name' into memory.
'file_name' must be the name of an existing program file stored in ASCII, 
bytecode or protected format. If ,R is specified, runs the file after loading.
LOAD,R keeps all data files open (unlike RUN). Existing variables will be 
cleared and any program in memory will be erased.
NOTES:
-   If 'file_name' does not include an extension, LOAD will try the name 
    specified, then an all-caps version, then an all-caps version with a .BAS 
    extension.
ERRORS:
-   If 'file_name' cannot be found, raises FILE NOT FOUND.
-   If a loaded ASCII file contains lines without line numbers, raises
    DIRECT STATEMENT IN FILE.


LOC function
location = LOC(file_num)
------------
Returns the current location in the file opened under number 'file_num'.
'file_num' is a number-valued expression in the range [0,255]. 
If the file is opened for INPUT, OUTPUT or APPEND, LOC returns the number
of 128-byte blocks read or written since opening the file. 
If the file is opened for RANDOM, LOC returns the record number last read or
written. 
If the file is opened to a COM device, LOC returns the number of characters
in the input buffer, with a maximum of 255. 
If the file is opened to KYBD:, LOC returns 0.
NOTES:
-   'file_num' must not be preceded by a #.
-   On OUTPUT or APPEND mode, before any writes LOC returns 0. After the 128th 
    character is written, LOC returns 1.
-   In INPUT mode, before any reads LOC returns 1. After the *129th* character
    is read, LOC returns 2. 
ERRORS:
-   If 'file_num' is not an open file, raises BAD FILE NUMBER.
-   If 'file_num' is open for output to a device, raises BAD FILE MODE.
-   If 'file_num' is not in [0,255], raises ILLEGAL FUNCTION CALL.
-   If 'file_num' is not in [-32768,32767], raises OVERFLOW.
-   If 'file_num' is a string, raises TYPE MISMATCH.


LOCATE statement
LOCATE [row] [, [col] [, [cursor_visible] [, [start_line] [, [stop_line] [,] ] ] 
----------------
Positions the cursor at 'row', 'col' on the screen and changes the cursor.
If 'cursor_visible' is 0, makes the cursor invisible; if it si 1, makes the 
cursor visible. The cursor shape is adjusted within a character cell to start
from 'start_line' and end on 'end_line' where 'start_line' and 'end_line' are 
in [0,31]. If 'start_line' or 'end_line' is greater than the character cell 
height (15), substitute 15. Cursor shape and visibility options have no effect 
in graphics mode. 
NOTES:
-   In GW-BASIC, the cursor shape option calls DOS INT 10h;01. What happens
    to the cursor is then determined by the video card; the result is
    fairly unlogical. PC-BASIC does not implement this quirk.
-   In GW-BASIC, cursor shape is preserved after changing to INSERT mode and 
    back; the INSERT cursor is different from the usual half-block. 
    In PC-BASIC, INSERT mode resets the cursor shape to default.
-   Locate accepts a 5th comma at the end, which is ignored.    
ERRORS:
-   If 'row' is outside the current view area, raises ILLEGAL FUNCTION CALL.
-   If 'col' is greater than the current width, raises ILLEGAL FUNCTION CALL.
-   If 'cursor_visible' is not in [0, 1], raises ILLEGAL FUNCTION CALL.
-   If any parameter is not in [-32768,32767], raises OVERFLOW.
-   If any parameter is a string, raises TYPE MISMATCH.


LOCK statement
LOCK [#] file_number [, record_0 ]
LOCK [#] file_number, [record_0] TO record_1
--------------
Locks a file or part of a file against access by other users. On a RANDOM file,
'file_number' is a number-valued expression in the range [0,255]. 
If specified, 'record_0' is the first record locked and 'record_1' is the last 
record locked. On any other kind of file 'record_0' and 'record_1' have no 
effect. If 'record_0' is not specified, it is assumed to be 1. If no records 
are specified, the whole file is locked.
NOTES:
-   In GW-BASIC under MS-DOS, the LOCK command required SHARE.EXE to be loaded.
    The maximum number of locks is specified in the SHARE command. If SHARE has
    not been activated or all locks are used, LOCK raises PERMISSION DENIED.
    PC-BASIC behaves as if SHARE has been activated with unlimited locks.
-   If 'file_number' is open for RANDOM, LOCK and UNLOCK statements must match 
    in terms of 'record_0' and 'record_1'. An unmatching UNLOCK will raise 
    PERMISSION DENIED.    
ERRORS:
-   Attempting to LOCK (part of) a file already locked raises PERMISSION DENIED.
-   If 'record_0' or 'record_1' is not in [1, 2^25-2], raises BAD RECORD NUMBER.
-   If 'file_num' is not an open file, raises BAD FILE NUMBER.
-   If 'file_num' is not in [0,255], raises ILLEGAL FUNCTION CALL.
-   If 'file_num' is not in [-32768,32767], raises OVERFLOW.
-   If any parameter is a string, raises TYPE MISMATCH.
    

LOF function
length = LOF(file_num)
------------
Returns the number of bytes in the file open under 'file_num'
'file_num' is a number-valued expression in the range [0,255]. 
NOTES:
-   If 'file_num' is open to a COM: device, LOF returns the number of bytes
    free in the input buffer.
ERRORS:
-   If 'file_num' is not an open file, raises BAD FILE NUMBER.
-   If 'file_num' is open for output to a device, raises BAD FILE MODE.
-   If 'file_num' is not in [0,255], raises ILLEGAL FUNCTION CALL.
-   If 'file_num' is a string, raises TYPE MISMATCH.
-   If 'file_num' is not in [-32768,32767], raises OVERFLOW.


LOG function
y = LOG(x)
------------
Returns the natural logarithm of 'x'.
'x' is a number-valued expression greater than zero.
NOTES:
-   Unless BASIC is run with the --double option, LOG(x) returns a single-
    precision value.
-   LOG(x) can differ from GW-BASIC by 1 in the least significant digit.
ERRORS:
-   If 'x' is a string, raises TYPE MISMATCH.
-   If 'x' is zero or less, raises ILLEGAL FUNCTION CALL.


LPOS function
position = LPOS(printer_number)
-------------
Returns the column position for a printer. 
'printer_number' is a number-valued expression in the range [0,3]. If it is 0
or 1, the position for LPT1 is returned. If it is 2, LPT2; 3, LPT3.
NOTES:
-   In GW-BASIC, when entering interactive mode, LPT1 (but not other printers) 
    is flushed and its position is reset to 1. This is not implemented in 
    PC-BASIC 3.23.
ERRORS:
-   If 'printer_number' is not in [0,3], raises ILLEGAL FUNCTION CALL.
-   If 'printer_number' is not in [-32768,32767], raises OVERFLOW.
-   If 'printer_number' is a string, raises TYPE MISMATCH.


LPRINT statement
----------------
See PRINT.


LPRINT USING statement
----------------------
See PRINT USING.


LSET and RSET statements
{L|R}SET string_name = expression
--------------
Assigns a value to a FIELD variable such that it overwrites the FIELD record.
With LSET, the value will be left-justified if it is shorter than the length of
the FIELD variable. With RSET, it will be right-justified.
'string_name' is a valid name of a string variable.
'expression' is a string-valued expression.
NOTES:
-   If 'string_name' is not a FIELD variable, the value is justified into the 
    existing string, which retains its length.
-   If 'expression' has a value that is longer than the length of the variable,
    it is truncated at the back at the length of the variable.
-   If LET is used on a FIELD variable instead of L|RSET, the variable is 
    detached from the field and becomes a normal string variable.
ERRORS:
-   If 'string_name' is not a string variable, TYPE MISMATCH is raised.
-   If 'expression' does not have a string value, TTYPE MISMATCH is raised.


MERGE statement
MERGE file_name
---------------
Overlays the lines of program 'file_name' into the existing program. The loaded
lines overwrite existing lines if they have the same line number. 'file_name' 
must be the name of an existing program file stored in ASCII format only. 
NOTES:
-   If 'file_name' does not include an extension, MERGE will try the name 
    specified, then an all-caps version, then an all-caps version with a .BAS 
    extension.
ERRORS:
-   If 'file_name' cannot be found, raises FILE NOT FOUND.
-   If 'file_name' was not saved as ASCII, raises BAD FILE MODE.
-   If a loaded ASCII file contains lines without line numbers, raises
    DIRECT STATEMENT IN FILE.
    

MID$ function
substring = MID$(string, position [, length])
-------------
Returns a substring of 'string' starting at 'position', counting from 1. The 
substring has length 'length' if specified, defaulting to 1.
'string' is a string-valued expression.
'position' is a number-valued expression between 1 and the string length.
'length' is a number-valued expression between 0 and 255, inclusive.
ERRORS:
-   If 'string' has a number value or 'position' or 'length' have string values,
    raises TYPE MISMATCH.
-   If 'position' is not in [1,255], raises ILLEGAL FUNCTION CALL.    
-   If 'length' is not in [0,255], raises ILLEGAL FUNCTION CALL.    
-   If 'position' or 'length' are not in [-32768,32767], raises OVERFLOW.


MID$ statement
MID$(string_name, position [, length]) = substring
--------------
Replaces part of 'string_name' with 'substring'.
'string_name' is a valid string variable name.
'position' is a number-valued expression between 1 and the string length.
'length' is a number-valued expression between 0 and 255, inclusive.
NOTES:
-   If 'substring' is longer than 'length', only the first 'length' characters
    are used.
-   If 'substring' is shorter than 'length', only LEN(substring) characters
    are replaced.
ERRORS:
-   If 'position' is greater than the length of 'string_name',
    raises ILLEGAL FUNCTION CALL, except if 'length' is specified as 0.
-   If 'position' is not in [1,255], raises ILLEGAL FUNCTION CALL.    
-   If 'length' is not in [0,255], raises ILLEGAL FUNCTION CALL.    
-   If 'position' or 'length' are not in [-32768,32767], raises OVERFLOW.


MKDIR statement
MKDIR path
---------------
Creates a directory. 'path' is a string-valued expression that specifies the 
path of the new directory.  
NOTES:
-   'path' will be modified into all-uppercase 8.3 format.
ERRORS:
-   If 'path' is not a string, raises TYPE MISMATCH.
-   If the parent directory of 'path' does not exist, raises PATH NOT FOUND.
-   If the pathname already exists, raises PATH/FILE ACCESS ERROR.
-   If the user has no write permission, raises PERMISSION DENIED.


MKD$ function
bytes = MKD$(double)
-------------
Retuns the internal 8-byte Microsoft Binary Format representation of a double-
precision number.
ERRORS:
-   If 'double' is a string, raises TYPE MISMATCH.


MKI$ function
bytes = MKI$(int)
-------------
Returns the internal 2-byte little-endian representation of an integer.
ERRORS:
-   If 'int' is a string, raises TYPE MISMATCH.
-   If 'int' is not in [-32768,32767], raises OVERFLOW.


MKS$ function
bytes = MKS$(single)
-------------
Retuns the internal 4-byte Microsoft Binary Format representation of a single-
precision number.
ERRORS:
-   If 'single' is a string, raises TYPE MISMATCH.


MOTOR statement
MOTOR [num]
---------------
Does nothing. 'num' is a number-valued expression between 0 and 255, inclusive.
NOTES:
-   This statement does nothing in GW-BASIC. Presumably, it is left over from a
    statement in older versions of MS Basic that would drive the cassette tape 
    player.
ERRORS:
-   If 'num' is not in [-32768, 32767], raises OVERFLOW.
-   If 'num' is not in [0, 255], raises ILLEGAL FUNCTION CALL.
-   If 'num' has a string value, raises TYPE MISMATCH. 


NAME statement
NAME old_name AS new_name
--------------
Renames the file 'old_name' into 'new_name'
'old_name' and 'new_name' are string-valued expressions.
NOTES:
-   'new_name' will be modified into all-uppercase 8.3 format.
ERRORS:
-   If 'old_name' or 'new_name' have number values, raises TYPE MISMATCH.
-   If 'old_name' does not exist, raises FILE NOT FOUND.
-   If 'old_name' is open, raises FILE ALREADY OPEN.
-   If 'new_name' exists, raises FILE ALREADY EXISTS.   


NEW statement
NEW 
-------------
Deletes the program in memory. Clears all variables, arrays and user functions.
Resets the DATA pointer. Removes DEFtype definitions. Clears COMMON 
declarations. Closes all files. Turns off all sound. Resets music foreground. 
Turns PEN and STRIG off. Clears all ON ERROR traps. Resets ERR and ERL to zero.
Disables all events. Resets the random number generator.    
Returns to interactive mode.
NOTE:
-   NEW implies CLEAR


NEXT statement
NEXT [var_0 [, var_1 [, ...] ] ]
--------------
Iterates a FOR--NEXT loop: increments the loop variable and jumps to the FOR 
statement. If no variables are specified, next matches the most recent FOR 
statement. Several nested NEXT statements can be consolidated into one by 
using the variable list. If one or more variables are specified, their order 
must match the order of earlier FOR statements.  
ERRORS:
-   If no FOR statement is found to match the NEXT statement and variables, 
    NEXT WITHOUT FOR is raised.
-   If 'var_0', ... are string names, NEXT WITHOUT FOR is raised.


OCT$ function
octal = OCT$(x)
-------------
Returns a string with the octal representation of 'x'. 'x' must be a 
number-valued expression between -32768 and 65535, inclusive. Values for 
negative 'x' are shown as two's-complement. 
ERRORS:
-   If 'x' is not in [-32768, 65535], OVERFLOW is raised.
-   If 'x' has a string value, TYPE MISMATCH is raised.


ON statement (switched jump)
ON n {GOTO|GOSUB} line_number_0 [, line_number_1 [, ...] ]
------------
Jumps to the 'n'th line number specified in the list. If 'n' is 0 or greater 
than the number of line_numbers in the list, no jump is performed. 'n' must 
be a number-valued expression in the range [0, 255]. IF GOTO is specified, 
the jump is unconditional; if GOSUB is specified, jumps to a subroutine.
ERRORS:
-   If 'n' is a string, raises TYPE MISMATCH.
-   If 'n' is not in [0,255], raises ILLEGAL FUNCTION CALL.
-   If 'n' is not in [-32768, 32767], OVERFLOW is raised.


ON statement (event trapping)
ON { COM(n) | KEY(n) | STRIG(n) | PEN | PLAY(n) | TIMER (x) } GOSUB line_number
------------
Defines an event trapping subroutine. 
The type of event is given by one of the following keywords:
COM(n)      'n' in [1,2] is the COM1 or COM2 port. The event is triggered 
            if data is present in the input buffer of the port.
KEY(n)      'n' is the key number: 1-10 are <F1>-<F10>, 11: <UP>, 12: <LEFT>, 
            13: <RIGHT>, 14: <DOWN>. 15-20 are user-definable. The event is
            triggered if the key is pressed.
STRIG(n)    'n' in [0,2,4,6] refer to the two fire triggers on two joysticks. 
            They event is triggered if the button is pressed.
PEN         In GW-BASIC, the event is triggered if the light pen is on the 
            screen. In PC-BASIC, the event is triggered if the left mouse 
            button is pressed. 
PLAY (n)    The event is triggered if there are exactly 'n' notes left on the
            music background queue. 'n' is a number-valued expression in [1,32]    
TIMER (x)   The event is triggered every 'x' seconds after the TIMER ON 
            statement. 'x' is a number-valued expression in [1, 86400].
Before event trapping is active, the event needs to be enabled using the event
statements: COM(n) ON | KEY(n) ON | STRIG(n) ON | PEN ON | PLAY ON | TIMER ON.
Events are not trapped in interactive mode.
ERRORS:
-   If 'n' or 'x' is a string, raises TYPE MISMATCH.
-   If 'n' or 'x' is outside the specified range, raises ILLEGAL FUNCTION CALL.
-   If 'n' is not in [-32768, 32767], raises OVERFLOW.


ON ERROR statement 
ON ERROR GOTO line_number
------------------
Defines an error handler. After this statement, any error causes the handler
routine to be called; no message is printed and execution is not stopped. The
handler routine is ended by a RESUME statement.
While in an error handling routine, events are paused and error trapping is
disabled. After the RESUME statement, events are picked up in the following 
order: KEY, TIMER, PLAY - the order of the others is unknown.
Error trapping remains active in interactive mode.
NOTES:
-   If 'line_number' is 0, turns off error trapping.


OPEN statement
OPEN mode_char, [#] file_num, file_name [, rec_len]
OPEN file_name 
    [ FOR { INPUT | OUTPUT | APPEND | RANDOM } ] 
    [ ACCESS { READ | WRITE | READ WRITE } ] 
    [ SHARED | LOCK { READ | WRITE | READ WRITE } ] 
    AS [#] file_num [ LEN = rec_len ]
--------------
Opens a data file or device.
'file_name' is a string-valued expression: the name of the file or device.
'file_num' is a number-valued expression in [1,3].
'rec_len' is a number-valued expression in [1,128]: the record length.
In the first syntax only:
-   'mode_char' is a string-valued expression of which the first character is
    one of "I" for INPUT, "O" for OUTPUT, "A" for APPEND, "R" for RANDOM.
The FOR modes:
-   INPUT opens a text file for reading and positions the file pointer at the 
    start.
-   OUTPUT truncates a text file at the start and opens it for writing. Any 
    data previously present in the file will be deleted.
-   APPEND opens a text file for writing at the end of any existing data.
-   RANDOM opens a file for random access; the file is divided in records of
    length 'rec_len'. If LEN is not specified, the record length defaults to 
    128. The file contents can be accessed using GET and PUT of the FIELD
    buffer; the FIELD buffer can be accessed through FIELD variables or through
    PRINT# and INPUT# statements. If a COM port is opened for RANDOM, access is
    byte-for-byte rather than through FIELD records; PRINT# and INPUT# access 
    the port directly. 
-   If no FOR mode / mode_char is specified, the file is opened for RANDOM.
The ACCESS modes:
-   If no ACCESS mode is specified, the default is READ WRITE for RANDOM,
    READ for INPUT, WRITE for OUTPUT, READ WRITE for APPEND.
-   If both FOR and ACCESS are specified, any ACCESS mode is allowed for
    RANDOM but for the other modes the access must match as above.
The SHARED/LOCK modes:    
-   If not specified, the file is locked exclusively for use by the 
    current BASIC process. Inside this process, a file may be opened multiple
    times for INPUT or RANDOM but only once for OUTPUT or APPEND, as long as it
    is again opened in default mode. It may not be opened in SHARED or any LOCK 
    modes.
-   If specified as SHARED, LOCK READ, LOCK WRITE or LOCK READ WRITE, whether 
    two OPEN statements may access the same file depends on one's LOCK status
    and the other's ACCESS status and vice versa. ASssuming the following:
        OPEN "file" ACCESS acc_1 lock_1 AS 1
        OPEN "file" ACCESS acc_2 lock_2 AS 2
    The following combinations are allowed, and vice versa:
               acc_2 >      READ    WRITE    READ WRITE
        lock_1 
        SHARED              yes     yes     yes      
        LOCK READ           no      yes     no
        LOCK WRITE          yes     no      no
        LOCK READ WRITE     no      no      no
In GW-BASIC under MS-DOS with SHARE active, these locks should be functioning
across a network as well as inside a single BASIC process. In PC-BASIC, the 
locks are only implemented internally; whether other processes may access the 
file will depend on the host OS.
NOTES:
-   For INPUT, OUTPUT and APPEND modes, LEN may be specified but is ignored.
-   In GW-BASIC, when opening one of the COM devices, the string 'file_name' 
    may contain additional qualifiers after the colon. This string has the form
    "COMn:[spd][,pty][,data][,stop][,RS][,CS[n]][,DS[n]][,CD[n]][,LF][,PE]"
    This is not implemented in PC-BASIC 3.23. 
-   If i/o is attempted contravening the FOR mode specified, the PRINT or INPUT
    statement will raise BAD FILE MODE.
-   If RANDOM i/o is attempted contravening the ACCESS mode specified, the 
    PUT or GET statement will raise PATH/FILE ACCESS ERROR.
-   The # is optional and has no effect.    
ERRORS:
-   If 'file_name' is empty or a non-existant device, raises BAD FILE NUMBER.
-   If FOR APPEND ACCESS WRITE is specified, raises PATH/FILE ACCESS ERROR.
-   If FOR and ACCESS mismatch in other ways, raises SYNTAX ERROR.
-   In GW-BASIC, if the COM: file_name does not follow the specification,
    BAD FILE NAME is raised.
-   If a file is already open for OUTPUT or APPEND, raises FILE ALREADY OPEN.
    This is not the case for devices.
-   IF 'rec_len' or 'file_num' have string values, raises TYPE MISMATCH.
-   If 'file_name' or 'mode_char' have number values, raises TYPE MISMATCH.
-   If 'file_num' is not in [1,3], raises BAD FILE NUMBER.
-   If 'file_num' is not in [0,255], raises ILLEGAL FUNCTION CALL.
-   If 'file_num' is not in [-32768,32767], raises OVERFLOW.
-   If 'rec_len' is not in [1,128], raises ILLEGAL FUNCTION CALL.
-   If 'rec_len' is not in [-32768,32767], raises OVERFLOW.
-   If 'mode_char' shorter than 1 or the first character is not in  
    ["I", "O", "A", "R"], raises BAD FILE MODE.
    


PRINT, PRINT# and LPRINT statements
{LPRINT| {PRINT|?} [# file_num,]} [expr_0] [;|,|SPC(n)|TAB(n)] [expr_1] [...]
---------------
Writes expressions to the screen, printer, file or device. If LPRINT is used, 
output goes to LPT1. If 'file_num' is specified, output goes to the file or 
device open under that number. ? is a shorthand for PRINT and has the same 
effect. 'expr_0' ... are expressions. 
Expressions can be separated by one of the following tokens:
;   The semicolon attaches two expressions tight together; strings will be 
    printed without any space in between, numbers will have one space 
    separating them, in addition to the space or minus sign that indicate 
    the sign of the number.
,   The expression after a comma will be positioned at the next available
    zone. The output file is divided in 14-character zones; if the width of the
    file is not a multiple of 14, the remaining spaces are unused and the first 
    zone ofn the next line is used instead. If the file has a width of less 
    than 14 characters, the zones are determined as if the file were wrapping 
    continuously.
SPC The expression SPC(n) produces 'n' spaces, where 'n' is a number-valued 
    expression. if 'n' is less than zero, it defaults to zero. If 'n' is 
    greater than the file width, it is taken modulo the file width.      
TAB The expression TAB(n) moves to column 'n', where 'n' is a number-valued 
    expression. if 'n' is less than zero, it defaults to zero. If 'n' is 
    greater than the file width, it is taken modulo the file width. If the 
    current column is greater than 'n', TAB moves to column 'n' on the next 
    line.     
If the print statement does not end in one of these four tokens, a newline is 
printed after the last expression.         
String expressions can be separated by one or more spaces, which has the same
effect as separating by semicolons
NOTES:
-   If an error is raised, the output before the error was encountered is 
    printed as normal.
ERRORS:
-   If 'n' is not in [-32768,65535], raises OVERFLOW.
-   If 'n' is a string, raises TYPE MISMATCH.


PRINT USING, PRINT# USING and LPRINT USING statements
{LPRINT| {PRINT|?} [# file,]} USING format; [ expr_0 [; expr_1 [; ...] ] ] [;]
---------------------
Writes a formatted string to the screen, printer, file or device.  If LPRINT is
used, output goes to LPT1. If 'file_num' is specified, output goes to the file 
or device open under that number. ? is a shorthand for PRINT and has the same 
effect. 'expr_0' ... are expressions. 
'format' is a string-valued expression that specifies the output format of the 
matching expression. The format tokens recognised are -
_   Escape character; causes the next character in the format string to be 
    printed as is rather than interpreted as a format token.
For string expressions:
!   Prints the first character of a string.
\\  Prints 2 or more characters of a string. A greater number of characters is 
    selected by separating the \s by spaces.
&   Prints the whole string.    
For numeric expressions, the format string specifies a width and alignment.
#   indicates a position for a digit.
.   indicates the decimal point.
,   before the decimal point causes digits to be grouped in threes separated by
    commas. After the decimal point it is not a token. 
    Provides one digit position.
The number of characters i the field must not exceed 24.     
Tokens preceding the number field:
+   causes the sign to be printed for positive as well as negative numbers.
    If before the number field, the sign is to be printed to the left of the 
    number. If after the number field, the sign will be printed to the right.
**  causes any leading spaces to be replaced with *s. 
    Provides two digit positions.
$$  causes a $ to be printed to the left of the number.
    Provides one digit position.
Tokens trailing the number field:
+   causes the sign to be printed for positive as well as negative numbers.
    If before the number field, the sign is to be printed to the left of the 
    number. If after the number field, the sign will be printed to the right.
-   after the number field causes the sign for negative numbers to be printed
    to the right of the number. Note that - preceding the field is not a token
    but printed literally.
^^^^ specify that scientific notation E+00 is to be used.    
Numeric expressions are always fully printed, even if they do not fit in the 
positions specified. If the number does not fit in the allowed space, a % is 
printed preceding it.
NOTES:
-   If there are more expressions than format fields, the format string is 
    wrapped around.
ERRORS:
-   If the expression doesn't match the format token type, TYPE MISMATCH is 
    raised.
-   If a number field exceeds 24 characters, ILLEGAL FUNCTION CALL is raised.
-   If the format string contains no tokens, ILLEGAL FUNCTION CALL is raised.   
-   If a number field contains no # characters, ILLEGAL FUCTION CALL is raised.


RSET statement
--------------
See LSET.


UNLOCK statement
----------------
ERRORS:
-   If 'file_number' is open for RANDOM, LOCK and UNLOCK statements must match 
    in terms of 'record_0' and 'record_1'. An unmatching UNLOCK will raise      
    PERMISSION DENIED.

