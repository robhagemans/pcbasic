#!/usr/bin/env python

"""
PC-BASIC 3.23 - GW-BASIC/BASICA/Cartridge BASIC compatible interpreter 

(c) 2013, 2014 Rob Hagemans 
This file is released under the GNU GPL version 3. 
"""

import os
import shutil
import logging

import plat

def main():
    """ Initialise and do requested operations. """
    # make imported modules available in main module
    global config
    try:
        import config
        if plat.system == 'Android':
            # resume from existing directory (or clear it if we're not resuming) 
            if not config.options['resume'] and os.path.exists(plat.temp_dir):
                shutil.rmtree(plat.temp_dir)
            if not os.path.exists(plat.temp_dir):
                os.mkdir(plat.temp_dir)
        # set up the logging system
        prepare_logging()        
        if config.options['version']:
            # in version mode, print version and exit
            logging.info(plat.version)
        elif config.options['help']:
            # in help mode, print usage and exit
            f = open(os.path.join(plat.info_dir, 'USAGE'))
            for line in f:
                logging.info(line[:-1])
        elif config.options['convert']:
            # in converter mode, convert and exit
            convert()
        else:
            # otherwise, go into BASIC    
            start_basic()
    finally:
        try:
            # clean up our temp dir if we made one
            if plat.temp_dir and plat.system != 'Android':
                shutil.rmtree(plat.temp_dir)
        except NameError:
            pass
     
def prepare_logging():
    """ Set up the logging system. """
    if config.options['version'] or config.options['help']:
        formatstr = '%(message)s'
        loglevel = logging.INFO
    else:
        # logging setup before we import modules and may need to log errors
        formatstr = '%(levelname)s: %(message)s'
        if config.options['debug']:
            loglevel = logging.DEBUG
        else:
            loglevel = logging.INFO
    logging.basicConfig(format=formatstr, level=loglevel)
        
def convert():
    """ Perform file format conversion. """
    import program
    import iolayer
    import error
    # set conversion output 
    # first arg, if given, is mode; second arg, if given, is outfile
    infile, outfile = '', ''
    conv = config.options['convert'].split(',')
    try:
        mode = conv.pop(0)
        infile = conv.pop(0)
        outfile = conv.pop(0)
    except IndexError:
        pass    
    # keep uppercase first letter    
    mode = mode[0].upper() if mode else 'A'
    # if not specified but positional argument is, use that.
    infile = (infile or config.options['program'] 
                or config.options['run'] or config.options['load'])
    # load & save in different format
    try:
        if infile:
            program.load(open_native_or_dos_filename(infile))
        elif plat.stdin:
            program.load(plat.stdin)      
        if outfile:
            # on save from command-line, use exact file name
            program.save(open(outfile, 'wb'), mode)
        elif plat.stdout:
            program.save(plat.stdout, mode)
    except error.RunError as e:
        logging.error(error.get_message(e.err))
    except EnvironmentError as e:    
        logging.error(str(e))    
        
def start_basic():
    """ Load & run programs and commands and hand over to interactive mode. """
    import program
    import run
    import error
    import state
    import iolayer
    reset = False
    # positional argument will be interpreted as program to run
    config.options['run'] = (config.options['run'] or config.options['program'])
    try:
        # resume from saved emulator state if requested and available
        resume = config.options['resume'] and state.load()
        # choose the video and sound backends
        backend, console = prepare_console()
        # greet, load and run only if not resuming   
        if not resume:    
            print_greeting(console)
            # load program
            prog = config.options['run'] or config.options['load']
            if prog:
                # on load, accept capitalised versions and default extension
                program.load(open_native_or_dos_filename(prog))
            # run commands
            command = config.options['exec']
            if config.options['run']: 
                command = 'RUN'
            if command:    
                run.execute(command)
        # start the interpreter (and get out if we ran with -q)
        run.loop(config.options['quit'])
    except error.RunError as e:
        logging.error(error.get_message(e.err))
    except error.Exit:
        pass
    except error.Reset:
        reset = True
    except KeyboardInterrupt:
        if config.options['debug']:
            raise
    finally:
        # delete state if resetting 
        if reset:
            state.delete()
            if plat.system == 'Android':
                shutil.rmtree(plat.temp_dir)
        else:   
            state.save()
        try:
            # fix the terminal on exit or crashes (important for ANSI terminals)
            if backend and backend.video:
                backend.video.close()
        except NameError:
            pass
        try:
            # close files if we opened any
            iolayer.close_all()
            iolayer.close_devices()
        except NameError:
            pass    
            
def prepare_console():
    """ Initialise backend and console. """
    import state
    import backend
    # load backend modules
    # this can't be done in backend.py as it would create circular dependency
    import console
    import error
    import fp
    backends = {
        'none': ('video_none', 'audio_none'),
        'cli': ('video_cli', 'audio_beep'),
        'ansi': ('video_curses', 'audio_beep'),
        'graphical': ('video_pygame', 'audio_pygame'), 
        }
    # interface choice shortcuts
    if config.options['ansi']:
        config.options['interface'] = 'ansi'
    elif config.options['cli']:
        config.options['interface'] = 'cli'
    elif not config.options['interface']:
        # interface defaults
        if not plat.stdin_is_tty or not plat.stdout_is_tty:
            config.options['interface'] = 'none'
        else:     
            config.options['interface'] = 'graphical'
    # select interface        
    video_name, audio_name = backends[config.options['interface']]
    backend.video, backend.audio = __import__(video_name), __import__(audio_name)
    if config.options['nosound']:
        backend.audio = __import__('audio_none')
    # initialise video backend before console
    if not backend.video or not backend.init_video():
        backend.video.close()
        logging.warning('Falling back to filter interface.')
        backend.video = __import__('video_none')
        if not backend.init_video():
            logging.error('Failed to initialise interface.')
            raise error.Exit()
    if not backend.init_audio():
        backend.audio = __import__('audio_none')
        logging.warning('Failed to initialise sound. Sound will be disabled.')
    if not state.loaded:    
        console.init_mode()    
    # set the output for maths error messages
    fp.init(error_stream=console)
    return backend, console
    
def print_greeting(console):
    """ Print the greeting and the KEY row if we're not running a program. """
    import var
    greeting = (
        'PC-BASIC 3.23%s\r'
        '(C) Copyright 2013-14 PC-BASIC authors. '
        'Type RUN "@:INFO" for more.\r'
        '%d Bytes free\r'
        'Ok\xff')
    # following GW, don't write greeting for redirected input 
    # or command-line run
    if (not config.options['run'] and not config.options['exec'] and
             not config.options['input'] and plat.stdin_is_tty):
        debugstr = ' [DEBUG mode]' if config.options['debug'] else ''
        console.write_line(greeting % (debugstr, var.total_mem))
        console.show_keys(True)
                
def open_native_or_dos_filename(infile, mode):
    """ If the specified file exists, open it; if not, try as DOS file name. """
    import iolayer
    import error
    try:
        # first try exact file name
        return open(infile, 'r')
    except EnvironmentError:
        # on load, accept capitalised versions and default extension
        return iolayer.open_file_or_device(0, 
                infile, mode='L', defext='BAS')
                        
if __name__ == "__main__":
    main()
        
