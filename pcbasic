#!/usr/bin/env python

"""
PC-BASIC 3.23 - GW-BASIC (R) compatible interpreter 

(c) 2013, 2014 Rob Hagemans 
This file is released under the GNU GPL version 3. 
please see text file COPYING for licence terms.

GW-BASIC is a trademark of Microsoft Corporation.
"""

import os
import shutil
import logging

import plat
import config

# logging setup before we import modules and may need to log errors
# do we log to a file? 
logfile = ''
formatstr = '%(levelname)s: %(message)s'
if config.options['debug']:
    logging.basicConfig(format=formatstr, level=logging.DEBUG)
elif logfile:
    logging.basicConfig(format=formatstr, level=logging.INFO,
                        filename=os.path.join(plat.info_dir, logfile))
else:
    logging.basicConfig(format=formatstr, level=logging.INFO)

# implied RUN
if config.options['program'] and not config.options['load']:
    config.options['run'] = True 

import backend
# load backend modules
# this can't be done in backend.py as it would create circular dependency
import video_none
import video_cli
import video_curses
import video_pygame
import audio_none
import audio_pygame
import audio_beep
backend.audio = audio_none
if config.options['filter'] or config.options['conv'] or (
        not config.options['graphical'] and not config.options['ansi'] and
        (not plat.stdin_is_tty or not plat.stdout_is_tty)):
    # redirected input or output leads to dumbterm use
    backend.video = video_none
    backend.audio = audio_none
elif config.options['cli'] and plat.stdout_is_tty:
    backend.video = video_cli
    backend.audio = audio_beep
elif config.options['ansi'] and plat.stdout_is_tty:
    backend.video = video_curses
    backend.audio = audio_beep
else:   
    backend.video = video_pygame   
    backend.audio = audio_pygame
if config.options['nosound']:
    backend.audio = audio_none

import run
import error
import oslayer
import console
import program
import state
import iolayer
import var
import fp

def main():
    """ Initialise and do operations or hand over to run module. """
    try:
        # in version mode, print version and exit
        if config.options['version']:
            logging.info(plat.version)
        # in convertor mode, convert and exit
        elif config.options['conv']:
            convert()
        else:
            reset = False
            try:
                # resume from saved emulator state if requested and available
                resume = config.options['resume'] and state.load()
                # choose the video and sound backends
                prepare_console()
                # greet, load and run only if not resuming   
                if not resume:    
                    print_greeting()
                    load_program()
                    run_commands()
                # start the interpreter (and get out if we ran with -q)
                run.loop(config.options['quit'])
            except error.RunError as e:
                logging.error(error.get_message(e.err))
            except error.Exit:
                pass
            except error.Reset:
                reset = True
            except KeyboardInterrupt:
                if config.options['debug']:
                    raise
            finally:
                # delete state if resetting 
                if reset:
                    state.delete()
                else:   
                    state.save()
    finally:
        # fix the terminal on exit or crashes (important for ANSI terminals)
        if backend.video:
            backend.video.close()
        iolayer.close_all()
        iolayer.close_devices()
        # clean up our temp dir
        if plat.temp_dir:
            shutil.rmtree(plat.temp_dir)
            
def prepare_console():
    """ Initialise backend and console. """
    # initialise video backend before console
    if not backend.video or not backend.init_video():
        backend.video.close()
        logging.warning('Falling back to filter interface.')
        backend.video = video_none
        if not backend.init_video():
            logging.error('Failed to initialise interface.')
            raise error.Exit()
    if not backend.init_audio():
        backend.audio = audio_none
        logging.warning('Failed to initialise sound. Sound will be disabled.')
    if not state.loaded:    
        console.init_mode()    
    # set the output for maths error messages
    fp.init(error_stream=console)
    
def convert():
    """ Perform file format conversion. """
    # set conversion output 
    # first arg, if given, is mode; second arg, if given, is outfile
    outfile = ''
    conv = config.options['conv'].split(':')
    try:
        mode = conv.pop(0)
        outfile = conv.pop(0)
    except IndexError:
        pass    
    # keep uppercase first letter    
    mode = mode[0].upper() if mode else 'A'
    # load & save in different format
    try:
        if config.options['program']:
            program.load(oslayer.safe_open(config.options['program'], "L", "R"))
        elif plat.stdin:
            program.load(plat.stdin)      
        if outfile:
            program.save(oslayer.safe_open(outfile, "S", "W"), mode)
        elif plat.stdout:
            program.save(plat.stdout, mode)
    except error.RunError as e:
        logging.error(error.get_message(e.err))
    
def print_greeting():
    """ Print the greeting if we're not running a program. """
    greeting = (
        'PC-BASIC 3.23%s\r'
        '(C) Copyright 2013, 2014 PC-BASIC authors. '
        'Type RUN "@:INFO" for more.\r'
        '%d Bytes free\r'
        'Ok\xff')
    if (not config.options['run'] and not config.options['exec']):
        debugstr = ' [DEBUG mode]' if config.options['debug'] else ''
        if plat.stdin_is_tty:
            console.write_line(greeting % (debugstr, var.total_mem))
    
def load_program():
    """ Load program from command line. """
    if config.options['program']:
        program.load(oslayer.safe_open(config.options['program'], "L", "R"))
    
def run_commands():
    """ Schedule commands or program from command line for running. """
    command = config.options['exec']
    if config.options['run']: 
        command = 'RUN'
    if command:    
        run.execute(command)
            
            
if __name__ == "__main__":
    main()
        
